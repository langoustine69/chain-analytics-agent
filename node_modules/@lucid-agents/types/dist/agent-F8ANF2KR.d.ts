import { Resource, Network } from 'x402/types';
import { z } from 'zod';
import { FetchFunction, AgentHttpHandlers, StreamPushEnvelope, StreamResult } from './http/index.js';
import { WalletMetadata, WalletConnector, WalletsRuntime } from './wallets/index.js';
import { AP2ExtensionDescriptor, AP2Runtime } from './ap2/index.js';
import { RegistrationEntry, TrustModel } from './identity/index.js';

/**
 * Solana address type (base58 encoded).
 */
type SolanaAddress = string;
/**
 * Outgoing payment limit configuration for a specific scope.
 */
type OutgoingLimit = {
    /** Maximum payment amount per individual request in USD (stateless) */
    maxPaymentUsd?: number;
    /** Maximum total outgoing amount in USD (stateful, tracks across requests) */
    maxTotalUsd?: number;
    /** Time window in milliseconds for total outgoing limit (optional - if not provided, lifetime limit) */
    windowMs?: number;
};
/**
 * Incoming payment limit configuration for a specific scope.
 */
type IncomingLimit = {
    /** Maximum payment amount per individual request in USD (stateless) */
    maxPaymentUsd?: number;
    /** Maximum total incoming amount in USD (stateful, tracks across requests) */
    maxTotalUsd?: number;
    /** Time window in milliseconds for total incoming limit (optional - if not provided, lifetime limit) */
    windowMs?: number;
};
/**
 * Outgoing limits configuration at different scopes.
 */
type OutgoingLimitsConfig = {
    /** Global outgoing limits applied to all payments */
    global?: OutgoingLimit;
    /** Per-target limits keyed by agent URL or domain */
    perTarget?: Record<string, OutgoingLimit>;
    /** Per-endpoint limits keyed by full endpoint URL */
    perEndpoint?: Record<string, OutgoingLimit>;
};
/**
 * Incoming limits configuration at different scopes.
 */
type IncomingLimitsConfig = {
    /** Global incoming limits applied to all payments */
    global?: IncomingLimit;
    /** Per-sender limits keyed by sender address or domain */
    perSender?: Record<string, IncomingLimit>;
    /** Per-endpoint limits keyed by full endpoint URL */
    perEndpoint?: Record<string, IncomingLimit>;
};
/**
 * Payment direction: outgoing (agent pays) or incoming (agent receives).
 */
type PaymentDirection = 'outgoing' | 'incoming';
/**
 * Payment record stored in the database.
 */
type PaymentRecord = {
    id?: number;
    groupName: string;
    scope: string;
    direction: PaymentDirection;
    amount: bigint;
    timestamp: number;
};
/**
 * Payment tracker interface for reading payment data.
 */
interface PaymentTracker {
    getAllData(): Promise<PaymentRecord[]>;
}
/**
 * Rate limiting configuration for a policy group.
 */
type RateLimitConfig = {
    /** Maximum number of payments allowed within the time window */
    maxPayments: number;
    /** Time window in milliseconds */
    windowMs: number;
};
/**
 * Payment policy group configuration.
 * Policy groups are evaluated in order - all groups must pass (first violation blocks the payment).
 */
type PaymentPolicyGroup = {
    /** Policy group identifier (e.g., "Daily Spending Limit", "API Usage Policy") */
    name: string;
    /** Outgoing payment limits at global, per-target, or per-endpoint scope */
    outgoingLimits?: OutgoingLimitsConfig;
    /** Incoming payment limits at global, per-sender, or per-endpoint scope */
    incomingLimits?: IncomingLimitsConfig;
    /** Whitelist of allowed recipient addresses or domains (for outgoing payments) */
    allowedRecipients?: string[];
    /** Blacklist of blocked recipient addresses or domains (for outgoing payments, takes precedence over whitelist) */
    blockedRecipients?: string[];
    /** Whitelist of allowed sender addresses or domains (for incoming payments) */
    allowedSenders?: string[];
    /** Blacklist of blocked sender addresses or domains (for incoming payments, takes precedence over whitelist) */
    blockedSenders?: string[];
    /** Rate limiting configuration (scoped per policy group) */
    rateLimits?: RateLimitConfig;
};
/**
 * Storage configuration for payment tracking.
 */
type PaymentStorageConfig = {
    /** Storage type: 'sqlite' (default), 'in-memory', or 'postgres' */
    type: 'sqlite' | 'in-memory' | 'postgres';
    /** SQLite-specific configuration */
    sqlite?: {
        /** Custom database path (defaults to `.data/payments.db`) */
        dbPath?: string;
    };
    /** Postgres-specific configuration */
    postgres?: {
        /** Postgres connection string */
        connectionString: string;
    };
};
/**
 * Payment configuration for x402 protocol.
 * Supports both EVM (0x...) and Solana (base58) addresses.
 */
type PaymentsConfig = {
    payTo: `0x${string}` | SolanaAddress;
    facilitatorUrl: Resource;
    network: Network;
    /** Optional policy groups for payment controls and limits */
    policyGroups?: PaymentPolicyGroup[];
    /** Optional storage configuration (defaults to SQLite) */
    storage?: PaymentStorageConfig;
};
/**
 * Price for an entrypoint - either a flat string or separate invoke/stream prices.
 */
type EntrypointPrice = string | {
    invoke?: string;
    stream?: string;
};
/**
 * Payment requirement for an entrypoint.
 */
type PaymentRequirement = {
    required: false;
} | {
    required: true;
    payTo: string;
    price: string;
    network: Network;
    facilitatorUrl?: string;
};
/**
 * HTTP-specific payment requirement that includes the Response object.
 */
type RuntimePaymentRequirement = {
    required: false;
} | (Extract<PaymentRequirement, {
    required: true;
}> & {
    response: Response;
});
/**
 * Payments runtime type.
 * Returned by AgentRuntime.payments when payments are configured.
 */
type PaymentsRuntime = {
    readonly config: PaymentsConfig;
    readonly isActive: boolean;
    requirements: (entrypoint: EntrypointDef, kind: 'invoke' | 'stream') => RuntimePaymentRequirement;
    activate: (entrypoint: EntrypointDef) => void;
    resolvePrice: (entrypoint: EntrypointDef, which: 'invoke' | 'stream') => string | null;
    /** Payment tracker for bi-directional payment tracking (outgoing and incoming) */
    readonly paymentTracker?: unknown;
    /** Optional rate limiter for rate limiting (only present if policy groups have rate limits) */
    readonly rateLimiter?: unknown;
    /** Policy groups configured for this runtime */
    readonly policyGroups?: PaymentPolicyGroup[];
    /**
     * Get fetch function with payment support.
     * Returns a fetch function that automatically includes x402 payment headers.
     * Returns null if payment context cannot be created (e.g., no wallet configured).
     */
    getFetchWithPayment: (runtime: AgentRuntime, network?: string) => Promise<((input: RequestInfo | URL, init?: RequestInit) => Promise<Response>) | null>;
};

/**
 * Metadata describing an agent.
 * Used for building Agent Cards (A2A protocol) and landing pages (HTTP).
 */
type AgentMeta = {
    name: string;
    version: string;
    description?: string;
    icon?: string;
    /**
     * Open Graph image URL for social previews and x402scan discovery.
     * Should be an absolute URL (e.g., "https://agent.com/og-image.png").
     * Recommended size: 1200x630px.
     */
    image?: string;
    /**
     * Canonical URL of the agent. Used for Open Graph tags.
     * If not provided, defaults to the agent's origin URL.
     */
    url?: string;
    /**
     * Open Graph type. Defaults to "website".
     */
    type?: 'website' | 'article';
};
/**
 * Agent manifest structure describing entrypoints and capabilities.
 */
type Manifest = {
    name: string;
    version: string;
    description?: string;
    entrypoints: Record<string, {
        description?: string;
        streaming: boolean;
        input_schema?: any;
        output_schema?: any;
        pricing?: {
            invoke?: string;
            stream?: string;
        };
    }>;
};
/**
 * Payment method configuration for x402 protocol.
 */
type PaymentMethod = {
    method: 'x402';
    payee: `0x${string}` | SolanaAddress;
    network: Network;
    endpoint?: Resource;
    priceModel?: {
        default?: string;
    };
    extensions?: {
        [vendor: string]: unknown;
    };
};
/**
 * Agent capabilities and feature flags.
 */
type AgentCapabilities = {
    streaming?: boolean;
    pushNotifications?: boolean;
    stateTransitionHistory?: boolean;
    extensions?: Array<AP2ExtensionDescriptor | Record<string, unknown>>;
};
/**
 * Agent Interface declaration (protocol binding + URL).
 */
type AgentInterface = {
    url: string;
    protocolBinding: string;
};
/**
 * Agent Card structure following the Agent Card specification.
 * Describes agent metadata, capabilities, skills, payments, and trust information.
 */
type AgentCard = {
    /** Protocol version (default: "1.0") */
    protocolVersion?: string;
    name: string;
    description?: string;
    /** DEPRECATED: Use supportedInterfaces instead */
    url?: string;
    /** Ordered list of supported interfaces (first is preferred) */
    supportedInterfaces?: AgentInterface[];
    provider?: {
        organization?: string;
        url?: string;
    };
    version?: string;
    /** Documentation URL */
    documentationUrl?: string;
    capabilities?: AgentCapabilities;
    /** Security schemes map */
    securitySchemes?: Record<string, unknown>;
    /** Security requirements */
    security?: unknown[];
    defaultInputModes?: string[];
    defaultOutputModes?: string[];
    skills?: Array<{
        id: string;
        name?: string;
        description?: string;
        tags?: string[];
        examples?: string[];
        inputModes?: string[];
        outputModes?: string[];
        security?: unknown[];
        [key: string]: unknown;
    }>;
    supportsAuthenticatedExtendedCard?: boolean;
    /** JWS signatures for card verification */
    signatures?: Array<{
        protected: string;
        signature: string;
        header?: Record<string, unknown>;
    }>;
    /** Icon URL */
    iconUrl?: string;
    payments?: PaymentMethod[];
    registrations?: RegistrationEntry[];
    trustModels?: TrustModel[];
    ValidationRequestsURI?: string;
    ValidationResponsesURI?: string;
    FeedbackDataURI?: string;
    [key: string]: unknown;
};
/**
 * Agent Card extended with entrypoint definitions from the manifest.
 */
type AgentCardWithEntrypoints = AgentCard & {
    entrypoints: Manifest['entrypoints'];
};
type TaskStatus = 'running' | 'completed' | 'failed' | 'cancelled';
type TaskResult<TOutput = unknown> = {
    output: TOutput;
    usage?: Usage;
    model?: string;
};
type TaskError = {
    code: string;
    message: string;
    details?: unknown;
};
type Task<TOutput = unknown> = {
    taskId: string;
    status: TaskStatus;
    result?: TaskResult<TOutput>;
    error?: TaskError;
    contextId?: string;
    createdAt: string;
    updatedAt: string;
};
type ListTasksRequest = {
    contextId?: string;
    status?: TaskStatus | TaskStatus[];
    limit?: number;
    offset?: number;
};
type ListTasksResponse = {
    tasks: Task[];
    total?: number;
    hasMore?: boolean;
};
type CancelTaskRequest = {
    taskId: string;
};
type CancelTaskResponse = Task;
type MessageContent = {
    text: string;
} | {
    parts: Array<{
        text?: string;
        [key: string]: unknown;
    }>;
};
type SendMessageRequest = {
    message: {
        role: 'user' | 'assistant' | 'system';
        content: MessageContent;
    };
    skillId: string;
    contextId?: string;
    metadata?: Record<string, unknown>;
};
type SendMessageResponse = {
    taskId: string;
    status: 'running';
};
type GetTaskResponse = Task;
type TaskUpdateEvent = {
    type: 'statusUpdate' | 'resultUpdate' | 'error';
    data: {
        taskId: string;
        status?: TaskStatus;
        result?: TaskResult;
        error?: TaskError;
    };
};
/**
 * Result from invoking an agent entrypoint.
 */
type InvokeAgentResult = {
    run_id?: string;
    status: string;
    output?: unknown;
    usage?: unknown;
    model?: string;
};
/**
 * Emit function for streaming agent responses.
 */
type StreamEmit = (chunk: {
    type: string;
    data: unknown;
}) => Promise<void> | void;
/**
 * Options for building an Agent Card.
 */
type BuildAgentCardOptions = {
    meta: AgentMeta;
    registry: Iterable<EntrypointDef>;
    origin: string;
};
/**
 * Options for creating A2A runtime.
 */
type CreateA2ARuntimeOptions = {};
/**
 * A2A client utilities for calling other agents.
 */
type A2AClient = {
    /**
     * Invokes an agent's entrypoint using the Agent Card.
     */
    invoke: (card: AgentCard, skillId: string, input: unknown, fetch?: FetchFunction) => Promise<InvokeAgentResult>;
    /**
     * Streams from an agent's entrypoint using the Agent Card.
     */
    stream: (card: AgentCard, skillId: string, input: unknown, emit: StreamEmit, fetch?: FetchFunction) => Promise<void>;
    /**
     * Convenience function that fetches an Agent Card and invokes an entrypoint.
     */
    fetchAndInvoke: (baseUrl: string, skillId: string, input: unknown, fetch?: FetchFunction) => Promise<InvokeAgentResult>;
    /**
     * Sends a message to an agent using A2A task-based operations.
     * Creates a task and returns the taskId immediately.
     */
    sendMessage: (card: AgentCard, skillId: string, input: unknown, fetch?: FetchFunction, options?: {
        contextId?: string;
        metadata?: Record<string, unknown>;
    }) => Promise<SendMessageResponse>;
    /**
     * Gets the status of a task.
     */
    getTask: (card: AgentCard, taskId: string, fetch?: FetchFunction) => Promise<Task>;
    /**
     * Subscribes to task updates via SSE.
     */
    subscribeTask: (card: AgentCard, taskId: string, emit: (chunk: TaskUpdateEvent) => Promise<void> | void, fetch?: FetchFunction) => Promise<void>;
    /**
     * Convenience function that fetches an Agent Card and sends a message.
     */
    fetchAndSendMessage: (baseUrl: string, skillId: string, input: unknown, fetch?: FetchFunction) => Promise<SendMessageResponse>;
    /**
     * Lists tasks with optional filtering.
     */
    listTasks: (card: AgentCard, filters?: ListTasksRequest, fetch?: FetchFunction) => Promise<ListTasksResponse>;
    /**
     * Cancels a running task.
     */
    cancelTask: (card: AgentCard, taskId: string, fetch?: FetchFunction) => Promise<Task>;
};
/**
 * Manifest runtime type.
 * Returned by AgentRuntime.manifest.
 */
type ManifestRuntime = {
    build: (origin: string) => AgentCardWithEntrypoints;
    invalidate: () => void;
};
/**
 * A2A runtime type.
 * Returned by AgentRuntime.a2a when A2A is configured.
 */
type A2ARuntime = {
    /**
     * Builds base Agent Card (A2A protocol only, no payments/identity/AP2).
     */
    buildCard: (origin: string) => AgentCardWithEntrypoints;
    /**
     * Fetches another agent's Agent Card.
     */
    fetchCard: (baseUrl: string, fetch?: FetchFunction) => Promise<AgentCard>;
    /**
     * Fetches another agent's Agent Card with entrypoints.
     */
    fetchCardWithEntrypoints: (baseUrl: string, fetch?: FetchFunction) => Promise<AgentCardWithEntrypoints>;
    /**
     * Client utilities for calling other agents.
     */
    client: A2AClient;
};

/**
 * Configuration for an agent instance.
 * Contains only the core agent metadata - extension configurations are managed by their respective runtimes.
 */
type AgentConfig = {
    meta: AgentMeta;
};

/**
 * Analytics runtime that reads from payment tracker.
 */
type AnalyticsRuntime = {
    /** Payment tracker instance */
    readonly paymentTracker: PaymentTracker | undefined;
};
/**
 * Analytics summary for a time window.
 */
type AnalyticsSummary = {
    /** Total outgoing payments in base units */
    outgoingTotal: bigint;
    /** Total incoming payments in base units */
    incomingTotal: bigint;
    /** Net (incoming - outgoing) in base units */
    netTotal: bigint;
    /** Number of outgoing transactions */
    outgoingCount: number;
    /** Number of incoming transactions */
    incomingCount: number;
    /** Time window start (timestamp) */
    windowStart?: number;
    /** Time window end (timestamp) */
    windowEnd?: number;
};
/**
 * Transaction record for analytics.
 */
type Transaction = PaymentRecord & {
    /** Formatted amount in USDC (e.g., "1.5" for 1.5 USDC) */
    amountUsdc: string;
    /** Formatted timestamp (ISO string) */
    timestampIso: string;
};
/**
 * Full analytics data structure.
 */
type AnalyticsData = {
    /** Summary statistics */
    summary: AnalyticsSummary;
    /** All transactions */
    transactions: Transaction[];
};

type JsonValue = string | number | boolean | null | {
    [key: string]: JsonValue;
} | JsonValue[];
type Schedule = {
    kind: 'interval';
    everyMs: number;
} | {
    kind: 'once';
    at: number;
};
/**
 * Serializable reference to the PAYER's wallet stored with a Hire.
 * This is the wallet that will PAY for invoking the agent's entrypoints.
 *
 * The agent's receiving address (payee) comes from the agent card's `payments` field.
 *
 * Contains metadata about the wallet for identification purposes.
 * The actual WalletConnector is provided at runtime via the walletResolver.
 */
type WalletRef = WalletMetadata & {
    /** Unique identifier for this wallet binding */
    id: string;
};
/**
 * @deprecated Use WalletRef instead. This type is kept for backwards compatibility.
 */
type WalletBinding = {
    walletId: string;
    network: 'base' | 'ethereum' | 'sepolia' | 'base-sepolia' | 'solana' | 'solana-devnet';
    address: string;
};
type AgentRef = {
    agentCardUrl: string;
    card?: AgentCardWithEntrypoints;
    cachedAt?: number;
};
/**
 * A Hire represents an agreement to invoke an agent's entrypoint on a schedule.
 *
 * The hire links:
 * - The agent to call (via agent card URL)
 * - Optional payer wallet metadata (for auditing/tracking)
 * - The schedule and parameters for invocations
 *
 * Payment is handled by the paymentContext provided to the scheduler runtime.
 */
type Hire = {
    id: string;
    agent: AgentRef;
    /** Optional wallet metadata for auditing/tracking. Payment is handled by paymentContext. */
    wallet?: WalletRef;
    status: 'active' | 'paused' | 'canceled';
    metadata?: Record<string, JsonValue>;
};
type JobStatus = 'pending' | 'leased' | 'failed' | 'completed' | 'paused';
type Job = {
    id: string;
    hireId: string;
    entrypointKey: string;
    input: JsonValue;
    schedule: Schedule;
    nextRunAt: number;
    attempts: number;
    maxRetries: number;
    status: JobStatus;
    idempotencyKey?: string;
    lease?: {
        workerId: string;
        expiresAt: number;
    };
    lastError?: string;
};
type SchedulerStore = {
    putHire(hire: Hire): Promise<void>;
    getHire(id: string): Promise<Hire | undefined>;
    deleteHire?(id: string): Promise<void>;
    putJob(job: Job): Promise<void>;
    getJob(id: string): Promise<Job | undefined>;
    getJobs?(): Promise<Job[]>;
    getDueJobs(now: number, limit: number): Promise<Job[]>;
    claimJob(jobId: string, workerId: string, leaseMs: number, now: number): Promise<boolean>;
    getExpiredLeases?(now: number): Promise<Job[]>;
};
/**
 * Arguments passed to the invoke function when executing a scheduled job.
 *
 * For the simple API (a2aClient + paymentContext), only manifest, entrypointKey,
 * input, and jobId are used. Payment is handled automatically by paymentContext.
 *
 * For the legacy custom invoke API, walletRef and walletConnector are also available.
 */
type InvokeArgs = {
    /** The agent's manifest/card containing entrypoints and payment info */
    manifest: AgentCardWithEntrypoints;
    /** The entrypoint to invoke on the agent */
    entrypointKey: string;
    /** Input data for the entrypoint */
    input: JsonValue;
    /** Unique job ID for tracking */
    jobId: string;
    /** Optional idempotency key to prevent duplicate executions */
    idempotencyKey?: string;
    /** @deprecated Wallet metadata - only used with custom invoke function */
    walletRef?: WalletRef;
    /** @deprecated Wallet connector - only used with custom invoke + walletResolver */
    walletConnector?: WalletConnector;
};
type InvokeFn = (args: InvokeArgs) => Promise<void>;
/**
 * Function to resolve a WalletRef to a WalletConnector at runtime.
 *
 * The WalletRef is a serializable reference to the PAYER's wallet.
 * The WalletConnector provides signing capabilities needed to make payments.
 *
 * This separation allows:
 * - Storing wallet references in a database (serializable WalletRef)
 * - Loading actual signing keys only when needed (WalletConnector)
 */
type WalletResolver = (walletRef: WalletRef) => Promise<WalletConnector | undefined>;
type OperationResult<T = void> = {
    success: true;
    data: T;
} | {
    success: false;
    error: string;
};
type SchedulerRuntime = {
    /**
     * Create a new hire to schedule agent invocations.
     *
     * @param input.agentCardUrl - URL to fetch the agent's card
     * @param input.entrypointKey - Which entrypoint to invoke on the agent
     * @param input.schedule - When/how often to invoke
     * @param input.jobInput - Input data to pass to the entrypoint
     * @param input.wallet - Optional wallet metadata for auditing (payment handled by paymentContext)
     */
    createHire(input: {
        agentCardUrl: string;
        entrypointKey: string;
        schedule: Schedule;
        jobInput: JsonValue;
        /** Optional wallet metadata for auditing. Payment is handled by paymentContext. */
        wallet?: WalletRef;
        maxRetries?: number;
        idempotencyKey?: string;
        metadata?: Record<string, JsonValue>;
    }): Promise<{
        hire: Hire;
        job: Job;
    }>;
    addJob(input: {
        hireId: string;
        entrypointKey: string;
        schedule: Schedule;
        jobInput: JsonValue;
        maxRetries?: number;
        idempotencyKey?: string;
    }): Promise<Job>;
    pauseHire(hireId: string): Promise<OperationResult>;
    resumeHire(hireId: string): Promise<OperationResult>;
    cancelHire(hireId: string): Promise<OperationResult>;
    pauseJob(jobId: string): Promise<OperationResult>;
    resumeJob(jobId: string, nextRunAt?: number): Promise<OperationResult>;
    tick(options?: {
        workerId?: string;
        concurrency?: number;
    }): Promise<void>;
    recoverExpiredLeases(): Promise<number>;
};
/**
 * Payment context from createRuntimePaymentContext.
 * Contains the x402-enabled fetch function for making paid calls.
 */
type PaymentContext = {
    fetchWithPayment: FetchFunction | null;
    walletAddress: `0x${string}` | null;
    chainId: number | null;
};

/**
 * Agent runtime interface.
 * This type is defined in the types package to avoid circular dependencies
 * between @lucid-agents/core and @lucid-agents/payments.
 *
 * The actual implementation is in @lucid-agents/core.
 */
type AgentRuntime = {
    /**
     * Agent core instance.
     */
    agent: AgentCore;
    wallets?: WalletsRuntime;
    payments?: PaymentsRuntime;
    analytics?: AnalyticsRuntime;
    a2a?: A2ARuntime;
    ap2?: AP2Runtime;
    scheduler?: SchedulerRuntime;
    handlers?: AgentHttpHandlers;
    entrypoints: EntrypointsRuntime;
    manifest: ManifestRuntime;
};

/**
 * Usage metrics for agent execution.
 */
type Usage = {
    prompt_tokens?: number;
    completion_tokens?: number;
    total_tokens?: number;
};
/**
 * Context provided to entrypoint handlers.
 */
type AgentContext = {
    key: string;
    input: unknown;
    signal: AbortSignal;
    metadata?: Record<string, unknown>;
    runId?: string;
    runtime?: AgentRuntime;
};
/**
 * Error thrown when input or output validation fails.
 */
declare class ZodValidationError extends Error {
    readonly kind: 'input' | 'output';
    readonly issues: z.ZodError['issues'];
    constructor(kind: 'input' | 'output', issues: z.ZodError['issues']);
}

/**
 * Handler function for non-streaming entrypoints.
 * Uses Omit to override the base AgentContext's input property with the typed input.
 */
type EntrypointHandler<TInput extends z.ZodTypeAny | undefined = z.ZodTypeAny | undefined, TOutput extends z.ZodTypeAny | undefined = z.ZodTypeAny | undefined> = (ctx: Omit<AgentContext, 'input'> & {
    input: TInput extends z.ZodTypeAny ? z.infer<TInput> : unknown;
}) => Promise<{
    output: TOutput extends z.ZodTypeAny ? z.infer<TOutput> : unknown;
    usage?: Usage;
    model?: string;
}>;
/**
 * Handler function for streaming entrypoints.
 * Uses Omit to override the base AgentContext's input property with the typed input.
 *
 * Note: This type references HTTP-specific stream types (SSE envelopes). For protocol-agnostic entrypoints,
 * use EntrypointHandler instead.
 */
type EntrypointStreamHandler<TInput extends z.ZodTypeAny | undefined = z.ZodTypeAny | undefined> = (ctx: Omit<AgentContext, 'input'> & {
    input: TInput extends z.ZodTypeAny ? z.infer<TInput> : unknown;
}, emit: (chunk: StreamPushEnvelope) => Promise<void> | void) => Promise<StreamResult>;
/**
 * Definition of an agent entrypoint.
 */
type EntrypointDef<TInput extends z.ZodTypeAny | undefined = z.ZodTypeAny | undefined, TOutput extends z.ZodTypeAny | undefined = z.ZodTypeAny | undefined> = {
    key: string;
    description?: string;
    input?: TInput;
    output?: TOutput;
    streaming?: boolean;
    price?: EntrypointPrice;
    network?: Network;
    handler?: EntrypointHandler<TInput, TOutput>;
    stream?: EntrypointStreamHandler<TInput>;
    metadata?: Record<string, unknown>;
};
/**
 * Entrypoints runtime type.
 * Returned by AgentRuntime.entrypoints.
 */
type EntrypointsRuntime = {
    add: (def: EntrypointDef) => void;
    list: () => Array<{
        key: string;
        description?: string;
        streaming: boolean;
    }>;
    snapshot: () => EntrypointDef[];
};

/**
 * Core agent interface providing entrypoint management.
 */
type AgentCore = {
    readonly config: AgentConfig;
    addEntrypoint: (entrypoint: EntrypointDef) => void;
    getEntrypoint: (key: string) => EntrypointDef | undefined;
    listEntrypoints: () => EntrypointDef[];
};

export { type EntrypointPrice as $, type AgentMeta as A, type BuildAgentCardOptions as B, type CancelTaskRequest as C, type Transaction as D, type EntrypointDef as E, type AnalyticsData as F, type GetTaskResponse as G, type SolanaAddress as H, type InvokeAgentResult as I, type IncomingLimit as J, type OutgoingLimitsConfig as K, type ListTasksRequest as L, type Manifest as M, type IncomingLimitsConfig as N, type OutgoingLimit as O, type PaymentMethod as P, type PaymentDirection as Q, type PaymentRecord as R, type SendMessageRequest as S, type TaskStatus as T, type Usage as U, type PaymentTracker as V, type RateLimitConfig as W, type PaymentPolicyGroup as X, type PaymentStorageConfig as Y, ZodValidationError as Z, type PaymentsConfig as _, type AgentRuntime as a, type PaymentRequirement as a0, type RuntimePaymentRequirement as a1, type PaymentsRuntime as a2, type JsonValue as a3, type Schedule as a4, type WalletRef as a5, type WalletBinding as a6, type AgentRef as a7, type Hire as a8, type JobStatus as a9, type Job as aa, type SchedulerStore as ab, type InvokeArgs as ac, type InvokeFn as ad, type WalletResolver as ae, type OperationResult as af, type SchedulerRuntime as ag, type PaymentContext as ah, type AgentCardWithEntrypoints as b, type AgentConfig as c, type AgentCore as d, type AgentContext as e, type EntrypointHandler as f, type EntrypointStreamHandler as g, type EntrypointsRuntime as h, type AgentCapabilities as i, type AgentInterface as j, type AgentCard as k, type TaskResult as l, type TaskError as m, type Task as n, type ListTasksResponse as o, type CancelTaskResponse as p, type MessageContent as q, type SendMessageResponse as r, type TaskUpdateEvent as s, type StreamEmit as t, type CreateA2ARuntimeOptions as u, type A2AClient as v, type ManifestRuntime as w, type A2ARuntime as x, type AnalyticsRuntime as y, type AnalyticsSummary as z };
