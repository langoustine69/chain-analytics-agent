import { z } from 'zod';

// src/card.ts
function buildAgentCard({
  meta,
  registry,
  origin
}) {
  const entrypoints = {};
  const entrypointList = Array.from(registry);
  const anyStreaming = entrypointList.some((e) => Boolean(e.stream));
  for (const e of entrypointList) {
    const manifestEntry = {
      description: e.description,
      streaming: Boolean(e.stream),
      input_schema: e.input ? z.toJSONSchema(e.input) : void 0,
      output_schema: e.output ? z.toJSONSchema(e.output) : void 0
    };
    entrypoints[e.key] = manifestEntry;
  }
  const defaultInputModes = ["application/json"];
  const defaultOutputModes = ["application/json", "text/plain"];
  const skills = entrypointList.map((e) => ({
    id: e.key,
    name: e.key,
    description: e.description,
    inputModes: defaultInputModes,
    outputModes: defaultOutputModes,
    streaming: Boolean(e.stream),
    x_input_schema: e.input ? z.toJSONSchema(e.input) : void 0,
    x_output_schema: e.output ? z.toJSONSchema(e.output) : void 0
  }));
  const capabilities = {
    streaming: anyStreaming,
    pushNotifications: false,
    stateTransitionHistory: true
  };
  const card = {
    protocolVersion: "1.0",
    name: meta.name,
    description: meta.description,
    url: origin.endsWith("/") ? origin : `${origin}/`,
    supportedInterfaces: [
      {
        url: origin.endsWith("/") ? origin : `${origin}/`,
        protocolBinding: "HTTP+JSON"
      }
    ],
    version: meta.version,
    provider: void 0,
    capabilities,
    defaultInputModes,
    defaultOutputModes,
    skills,
    supportsAuthenticatedExtendedCard: false,
    entrypoints
  };
  return card;
}
async function fetchAgentCard(baseUrl, fetchImpl) {
  const card = await fetchAgentCardInternal(baseUrl, fetchImpl);
  const { entrypoints, ...agentCard } = card;
  return agentCard;
}
async function fetchAgentCardWithEntrypoints(baseUrl, fetchImpl) {
  return fetchAgentCardInternal(baseUrl, fetchImpl);
}
function parseAgentCard(json) {
  if (!json || typeof json !== "object") {
    throw new Error("Agent Card must be an object");
  }
  const obj = json;
  if (typeof obj.name !== "string") {
    throw new Error("Agent Card must have a name field");
  }
  return {
    name: obj.name,
    description: typeof obj.description === "string" ? obj.description : void 0,
    url: typeof obj.url === "string" ? obj.url : void 0,
    version: typeof obj.version === "string" ? obj.version : void 0,
    provider: obj.provider,
    capabilities: obj.capabilities,
    defaultInputModes: Array.isArray(obj.defaultInputModes) ? obj.defaultInputModes : void 0,
    defaultOutputModes: Array.isArray(obj.defaultOutputModes) ? obj.defaultOutputModes : void 0,
    skills: Array.isArray(obj.skills) ? obj.skills : void 0,
    supportsAuthenticatedExtendedCard: typeof obj.supportsAuthenticatedExtendedCard === "boolean" ? obj.supportsAuthenticatedExtendedCard : void 0,
    entrypoints: obj.entrypoints ?? {},
    payments: Array.isArray(obj.payments) ? obj.payments : void 0,
    registrations: Array.isArray(obj.registrations) ? obj.registrations : void 0,
    trustModels: Array.isArray(obj.trustModels) ? obj.trustModels : void 0,
    ValidationRequestsURI: typeof obj.ValidationRequestsURI === "string" ? obj.ValidationRequestsURI : void 0,
    ValidationResponsesURI: typeof obj.ValidationResponsesURI === "string" ? obj.ValidationResponsesURI : void 0,
    FeedbackDataURI: typeof obj.FeedbackDataURI === "string" ? obj.FeedbackDataURI : void 0
  };
}
function findSkill(card, skillId) {
  return card.skills?.find((skill) => skill.id === skillId);
}
function hasCapability(card, capability) {
  if (!card?.capabilities) {
    return false;
  }
  return Boolean(card.capabilities[capability]);
}
function hasSkillTag(card, tag) {
  if (!card?.skills) {
    return false;
  }
  return card.skills.some(
    (skill) => skill.tags?.some((t) => t.toLowerCase() === tag.toLowerCase())
  );
}
function supportsPayments(card) {
  return Boolean(card?.payments && card.payments.length > 0);
}
function hasTrustInfo(card) {
  return Boolean(card?.trustModels?.length || card?.registrations?.length);
}
async function fetchAgentCardInternal(baseUrl, fetchImpl) {
  const fetchFn = fetchImpl ?? globalThis.fetch;
  if (!fetchFn) {
    throw new Error("fetch is not available");
  }
  const normalizedBase = baseUrl.replace(/\/$/, "");
  const agentcardUrls = [];
  if (baseUrl.startsWith("http://") || baseUrl.startsWith("https://")) {
    agentcardUrls.push(baseUrl);
  }
  agentcardUrls.push(`${normalizedBase}/.well-known/agent-card.json`);
  agentcardUrls.push(`${normalizedBase}/.well-known/agent.json`);
  agentcardUrls.push(`${normalizedBase}/agentcard.json`);
  let lastError = null;
  for (const agentcardUrl of agentcardUrls) {
    try {
      let url;
      try {
        url = new URL(agentcardUrl);
      } catch {
        url = new URL(agentcardUrl, baseUrl);
      }
      const response = await fetchFn(url.toString());
      if (response.ok) {
        const json = await response.json();
        return parseAgentCard(json);
      }
      if (response.status !== 404) {
        lastError = new Error(
          `Failed to fetch Agent Card: ${response.status} ${response.statusText}`
        );
      }
    } catch (error) {
      if (!lastError) {
        lastError = error instanceof Error ? error : new Error("Failed to fetch Agent Card");
      }
    }
  }
  throw lastError || new Error(
    `Failed to fetch Agent Card from any well-known path. Tried: ${agentcardUrls.join(", ")}`
  );
}

// src/client.ts
async function invokeAgent(card, skillId, input, fetchImpl) {
  const skill = findSkill(card, skillId);
  if (!skill) {
    throw new Error(`Skill "${skillId}" not found in Agent Card`);
  }
  const baseUrl = card.url;
  if (!baseUrl) {
    throw new Error("Agent Card missing url field");
  }
  const fetchFn = fetchImpl ?? globalThis.fetch;
  if (!fetchFn) {
    throw new Error("fetch is not available");
  }
  const url = new URL(`/entrypoints/${skillId}/invoke`, baseUrl);
  const response = await fetchFn(url.toString(), {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({ input })
  });
  if (!response.ok) {
    throw new Error(
      `Agent invocation failed: ${response.status} ${response.statusText}`
    );
  }
  return await response.json();
}
async function streamAgent(card, skillId, input, emit, fetchImpl) {
  const skill = findSkill(card, skillId);
  if (!skill) {
    throw new Error(`Skill "${skillId}" not found in Agent Card`);
  }
  const baseUrl = card.url;
  if (!baseUrl) {
    throw new Error("Agent Card missing url field");
  }
  const fetchFn = fetchImpl ?? globalThis.fetch;
  if (!fetchFn) {
    throw new Error("fetch is not available");
  }
  const url = new URL(`/entrypoints/${skillId}/stream`, baseUrl);
  const response = await fetchFn(url.toString(), {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({ input })
  });
  if (!response.ok) {
    throw new Error(
      `Agent stream failed: ${response.status} ${response.statusText}`
    );
  }
  if (!response.body) {
    throw new Error("Response body is null");
  }
  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  let buffer = "";
  let currentEvent = null;
  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split("\n");
      buffer = lines.pop() || "";
      for (const line of lines) {
        if (line.startsWith("event: ")) {
          currentEvent = {
            type: line.slice(7).trim(),
            data: ""
          };
        } else if (line.startsWith("data: ")) {
          if (currentEvent) {
            currentEvent.data += (currentEvent.data ? "\n" : "") + line.slice(6);
          }
        } else if (line === "" && currentEvent) {
          try {
            const data = currentEvent.data ? JSON.parse(currentEvent.data) : {};
            await emit({ type: currentEvent.type, data });
          } catch (error) {
            await emit({ type: currentEvent.type, data: currentEvent.data });
          }
          currentEvent = null;
        }
      }
    }
    if (buffer.trim() && currentEvent) {
      try {
        const data = currentEvent.data ? JSON.parse(currentEvent.data) : {};
        await emit({ type: currentEvent.type, data });
      } catch {
        await emit({ type: currentEvent.type, data: currentEvent.data });
      }
    }
  } finally {
    reader.releaseLock();
  }
}
async function fetchAndInvoke(baseUrl, skillId, input, fetchImpl) {
  const card = await fetchAgentCard(baseUrl, fetchImpl);
  return invokeAgent(card, skillId, input, fetchImpl);
}
async function sendMessage(card, skillId, input, fetchImpl, options) {
  const skill = findSkill(card, skillId);
  if (!skill) {
    throw new Error(`Skill "${skillId}" not found in Agent Card`);
  }
  const baseUrl = card.url;
  if (!baseUrl) {
    throw new Error("Agent Card missing url field");
  }
  const fetchFn = fetchImpl ?? globalThis.fetch;
  if (!fetchFn) {
    throw new Error("fetch is not available");
  }
  const messageContent = {
    text: typeof input === "string" ? input : JSON.stringify(input)
  };
  const requestBody = {
    message: {
      role: "user",
      content: messageContent
    },
    skillId,
    contextId: options?.contextId,
    metadata: options?.metadata
  };
  const url = new URL("/tasks", baseUrl);
  const response = await fetchFn(url.toString(), {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(requestBody)
  });
  if (!response.ok) {
    throw new Error(
      `Task creation failed: ${response.status} ${response.statusText}`
    );
  }
  return await response.json();
}
async function getTask(card, taskId, fetchImpl) {
  const baseUrl = card.url;
  if (!baseUrl) {
    throw new Error("Agent Card missing url field");
  }
  const fetchFn = fetchImpl ?? globalThis.fetch;
  if (!fetchFn) {
    throw new Error("fetch is not available");
  }
  const url = new URL(`/tasks/${taskId}`, baseUrl);
  const response = await fetchFn(url.toString(), {
    method: "GET",
    headers: {
      "Content-Type": "application/json"
    }
  });
  if (!response.ok) {
    throw new Error(
      `Failed to get task: ${response.status} ${response.statusText}`
    );
  }
  return await response.json();
}
async function subscribeTask(card, taskId, emit, fetchImpl) {
  const baseUrl = card.url;
  if (!baseUrl) {
    throw new Error("Agent Card missing url field");
  }
  const fetchFn = fetchImpl ?? globalThis.fetch;
  if (!fetchFn) {
    throw new Error("fetch is not available");
  }
  const url = new URL(`/tasks/${taskId}/subscribe`, baseUrl);
  const response = await fetchFn(url.toString(), {
    method: "GET",
    headers: {
      Accept: "text/event-stream"
    }
  });
  if (!response.ok) {
    throw new Error(
      `Failed to subscribe to task: ${response.status} ${response.statusText}`
    );
  }
  if (!response.body) {
    throw new Error("Response body is null");
  }
  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  let buffer = "";
  let currentEvent = null;
  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split("\n");
      buffer = lines.pop() || "";
      for (const line of lines) {
        if (line.startsWith("event: ")) {
          currentEvent = {
            type: line.slice(7).trim(),
            data: ""
          };
        } else if (line.startsWith("data: ")) {
          if (currentEvent) {
            currentEvent.data += (currentEvent.data ? "\n" : "") + line.slice(6);
          }
        } else if (line === "" && currentEvent) {
          try {
            const data = currentEvent.data ? JSON.parse(currentEvent.data) : {};
            await emit({ type: currentEvent.type, data });
          } catch (error) {
            await emit({
              type: currentEvent.type,
              data: {
                taskId,
                error: {
                  code: "parse_error",
                  message: currentEvent.data || "Failed to parse event data"
                }
              }
            });
          }
          currentEvent = null;
        }
      }
    }
    if (buffer.trim() && currentEvent) {
      try {
        const data = currentEvent.data ? JSON.parse(currentEvent.data) : {};
        await emit({ type: currentEvent.type, data });
      } catch {
        await emit({
          type: currentEvent.type,
          data: {
            taskId,
            error: {
              code: "parse_error",
              message: currentEvent.data || "Failed to parse event data"
            }
          }
        });
      }
    }
  } finally {
    reader.releaseLock();
  }
}
async function fetchAndSendMessage(baseUrl, skillId, input, fetchImpl) {
  const card = await fetchAgentCard(baseUrl, fetchImpl);
  return sendMessage(card, skillId, input, fetchImpl);
}
async function listTasks(card, filters, fetchImpl) {
  const baseUrl = card.url;
  if (!baseUrl) {
    throw new Error("Agent Card missing url field");
  }
  const fetchFn = fetchImpl ?? globalThis.fetch;
  if (!fetchFn) {
    throw new Error("fetch is not available");
  }
  const url = new URL("/tasks", baseUrl);
  if (filters?.contextId) url.searchParams.set("contextId", filters.contextId);
  if (filters?.status) {
    const statusArray = Array.isArray(filters.status) ? filters.status : [filters.status];
    url.searchParams.set("status", statusArray.join(","));
  }
  if (filters?.limit) url.searchParams.set("limit", String(filters.limit));
  if (filters?.offset) url.searchParams.set("offset", String(filters.offset));
  const response = await fetchFn(url.toString(), {
    method: "GET",
    headers: { "Content-Type": "application/json" }
  });
  if (!response.ok) {
    throw new Error(
      `Failed to list tasks: ${response.status} ${response.statusText}`
    );
  }
  return await response.json();
}
async function cancelTask(card, taskId, fetchImpl) {
  const baseUrl = card.url;
  if (!baseUrl) {
    throw new Error("Agent Card missing url field");
  }
  const fetchFn = fetchImpl ?? globalThis.fetch;
  if (!fetchFn) {
    throw new Error("fetch is not available");
  }
  const url = new URL(`/tasks/${taskId}/cancel`, baseUrl);
  const response = await fetchFn(url.toString(), {
    method: "POST",
    headers: { "Content-Type": "application/json" }
  });
  if (!response.ok) {
    throw new Error(
      `Failed to cancel task: ${response.status} ${response.statusText}`
    );
  }
  return await response.json();
}
async function waitForTask(client, card, taskId, maxWaitMs = 3e4) {
  const startTime = Date.now();
  while (Date.now() - startTime < maxWaitMs) {
    const task = await client.getTask(card, taskId);
    if (task.status === "completed" || task.status === "failed") {
      return task;
    }
    await new Promise((resolve) => setTimeout(resolve, 100));
  }
  throw new Error(`Task ${taskId} did not complete within ${maxWaitMs}ms`);
}

// src/runtime.ts
function createA2ARuntime(runtime, _options) {
  const a2aRuntime = {
    buildCard(origin) {
      const entrypoints = runtime.entrypoints.snapshot();
      return buildAgentCard({
        meta: runtime.agent.config.meta,
        registry: entrypoints,
        origin
      });
    },
    async fetchCard(baseUrl, fetchImpl) {
      return fetchAgentCard(baseUrl, fetchImpl);
    },
    async fetchCardWithEntrypoints(baseUrl, fetchImpl) {
      return fetchAgentCardWithEntrypoints(baseUrl, fetchImpl);
    },
    client: {
      invoke: invokeAgent,
      stream: streamAgent,
      fetchAndInvoke,
      sendMessage,
      getTask,
      subscribeTask,
      fetchAndSendMessage,
      listTasks,
      cancelTask
    }
  };
  return a2aRuntime;
}

// src/extension.ts
function a2a() {
  return {
    name: "a2a",
    build(_ctx) {
      return {
        a2a: {}
      };
    },
    onBuild(runtime) {
      const a2aRuntime = createA2ARuntime(runtime);
      runtime.a2a = a2aRuntime;
    }
  };
}

export { a2a, buildAgentCard, cancelTask, createA2ARuntime, fetchAgentCard, fetchAgentCardWithEntrypoints, fetchAndInvoke, fetchAndSendMessage, findSkill, getTask, hasCapability, hasSkillTag, hasTrustInfo, invokeAgent, listTasks, parseAgentCard, sendMessage, streamAgent, subscribeTask, supportsPayments, waitForTask };
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map