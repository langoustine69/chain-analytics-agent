import { BuildAgentCardOptions, AgentCardWithEntrypoints, AgentCard, AgentCapabilities, InvokeAgentResult, StreamEmit, SendMessageResponse, Task, TaskUpdateEvent, ListTasksRequest, ListTasksResponse, A2AClient, CreateA2ARuntimeOptions, A2ARuntime } from '@lucid-agents/types/a2a';
import { FetchFunction } from '@lucid-agents/types/http';
import { AgentRuntime, Extension } from '@lucid-agents/types/core';

/**
 * Builds base Agent Card following A2A protocol.
 * Does NOT include payments, identity, or AP2 extensions.
 * Does NOT add pricing to entrypoints.
 */
declare function buildAgentCard({ meta, registry, origin, }: BuildAgentCardOptions): AgentCardWithEntrypoints;
/**
 * Fetches Agent Card from another agent's well-known endpoint.
 * Tries multiple well-known paths for compatibility with different agent implementations.
 *
 * Per ERC-8004, the endpoint may already be a full URL to the agent card.
 * Per A2A spec section 5.3, the recommended discovery path is /.well-known/agent-card.json.
 */
declare function fetchAgentCard(baseUrl: string, fetchImpl?: FetchFunction): Promise<AgentCard>;
declare function fetchAgentCardWithEntrypoints(baseUrl: string, fetchImpl?: FetchFunction): Promise<AgentCardWithEntrypoints>;
/**
 * Parses and validates Agent Card JSON structure.
 */
declare function parseAgentCard(json: unknown): AgentCardWithEntrypoints;
/**
 * Finds a skill by ID in an Agent Card.
 */
declare function findSkill(card: AgentCard, skillId: string): AgentCard['skills'][number] | undefined;
/**
 * Checks if an agent supports a specific capability.
 *
 * @param card - Agent card
 * @param capability - Capability to check ('streaming' | 'pushNotifications' | 'stateTransitionHistory')
 * @returns true if the capability is supported
 */
declare function hasCapability(card: AgentCard | null, capability: keyof AgentCapabilities): boolean;
/**
 * Checks if an agent has a specific skill tag.
 *
 * @param card - Agent card
 * @param tag - Skill tag to check
 * @returns true if the agent has the tag
 */
declare function hasSkillTag(card: AgentCard | null, tag: string): boolean;
/**
 * Checks if an agent supports payments.
 *
 * @param card - Agent card
 * @returns true if the agent has payment methods configured
 */
declare function supportsPayments(card: AgentCard | null): boolean;
/**
 * Checks if an agent has trust/identity information.
 *
 * @param card - Agent card
 * @returns true if the agent has trust models or registrations
 */
declare function hasTrustInfo(card: AgentCard | null): boolean;

/**
 * Invokes an agent's entrypoint using the Agent Card.
 */
declare function invokeAgent(card: AgentCard, skillId: string, input: unknown, fetchImpl?: FetchFunction): Promise<InvokeAgentResult>;
/**
 * Streams from an agent's entrypoint using the Agent Card.
 */
declare function streamAgent(card: AgentCard, skillId: string, input: unknown, emit: StreamEmit, fetchImpl?: FetchFunction): Promise<void>;
/**
 * Convenience function that fetches an Agent Card and invokes an entrypoint.
 */
declare function fetchAndInvoke(baseUrl: string, skillId: string, input: unknown, fetchImpl?: FetchFunction): Promise<InvokeAgentResult>;
/**
 * Sends a message to an agent using A2A task-based operations.
 * Creates a task and returns the taskId immediately.
 */
declare function sendMessage(card: AgentCard, skillId: string, input: unknown, fetchImpl?: FetchFunction, options?: {
    contextId?: string;
    metadata?: Record<string, unknown>;
}): Promise<SendMessageResponse>;
/**
 * Gets the status of a task.
 */
declare function getTask(card: AgentCard, taskId: string, fetchImpl?: FetchFunction): Promise<Task>;
/**
 * Subscribes to task updates via SSE.
 */
declare function subscribeTask(card: AgentCard, taskId: string, emit: (chunk: TaskUpdateEvent) => Promise<void> | void, fetchImpl?: FetchFunction): Promise<void>;
/**
 * Convenience function that fetches an Agent Card and sends a message.
 */
declare function fetchAndSendMessage(baseUrl: string, skillId: string, input: unknown, fetchImpl?: FetchFunction): Promise<SendMessageResponse>;
/**
 * Lists tasks with optional filtering.
 */
declare function listTasks(card: AgentCard, filters?: ListTasksRequest, fetchImpl?: FetchFunction): Promise<ListTasksResponse>;
/**
 * Cancels a running task.
 */
declare function cancelTask(card: AgentCard, taskId: string, fetchImpl?: FetchFunction): Promise<Task>;
/**
 * Helper function to wait for a task to complete.
 * Polls task status until it's completed or failed.
 */
declare function waitForTask<TOutput = unknown>(client: A2AClient, card: AgentCard, taskId: string, maxWaitMs?: number): Promise<Task<TOutput>>;

/**
 * Creates A2A runtime from an AgentRuntime.
 * Always returns a runtime (A2A is always available).
 */
declare function createA2ARuntime(runtime: AgentRuntime, _options?: CreateA2ARuntimeOptions): A2ARuntime;

declare function a2a(): Extension<{
    a2a: A2ARuntime;
}>;

export { a2a, buildAgentCard, cancelTask, createA2ARuntime, fetchAgentCard, fetchAgentCardWithEntrypoints, fetchAndInvoke, fetchAndSendMessage, findSkill, getTask, hasCapability, hasSkillTag, hasTrustInfo, invokeAgent, listTasks, parseAgentCard, sendMessage, streamAgent, subscribeTask, supportsPayments, waitForTask };
