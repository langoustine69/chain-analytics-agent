import { createX402LLM } from '@lucid-agents/payments';
import { buildAgentCard } from '@lucid-agents/a2a';

// src/axllm/index.ts
var DEFAULT_PROVIDER = "openai";
var DEFAULT_MODEL = "gpt-5";
function createAxLLMClient(options = {}) {
  const resolved = resolveOptions(options);
  const logger = options.logger;
  const axInstance = (() => {
    if (options.client) return options.client;
    const fromFactory = options.clientFactory?.();
    if (fromFactory) return fromFactory;
    try {
      return createX402LLM(buildCreateOptions(resolved, options.x402));
    } catch (error) {
      logger?.warn?.(
        `[agent-kit] failed to initialise Ax LLM client: ${error.message}`,
        error
      );
      return null;
    }
  })();
  return {
    ax: axInstance,
    isConfigured() {
      return Boolean(axInstance);
    }
  };
}
function resolveOptions(options) {
  const env = readEnv(options.env);
  const provider = options.provider ?? env.AX_PROVIDER ?? env.AXLLM_PROVIDER ?? env.OPENAI_PROVIDER ?? DEFAULT_PROVIDER;
  const model = options.model ?? env.AX_MODEL ?? env.AXLLM_MODEL ?? env.OPENAI_MODEL ?? DEFAULT_MODEL;
  const apiKey = options.apiKey ?? env.OPENAI_API_KEY;
  const apiUrl = options.apiUrl ?? env.AX_API_URL ?? env.AXLLM_API_URL ?? env.OPENAI_API_URL;
  const temperature = options.temperature ?? parseNumber(
    env.AX_TEMPERATURE ?? env.AXLLM_TEMPERATURE ?? env.OPENAI_TEMPERATURE
  );
  const debug = options.debug ?? parseBoolean(env.AX_DEBUG ?? env.AXLLM_DEBUG) ?? false;
  return { provider, model, apiKey, apiUrl, temperature, debug };
}
function buildCreateOptions(resolved, overrides) {
  const x402 = overrides ? { ...overrides } : {};
  const aiOverrides = overrides?.ai ? { ...overrides.ai } : {};
  const aiConfigOverrides = aiOverrides.config && typeof aiOverrides.config === "object" ? { ...aiOverrides.config } : void 0;
  const aiOptionOverrides = aiOverrides.options && typeof aiOverrides.options === "object" ? { ...aiOverrides.options } : void 0;
  const finalTemperature = aiConfigOverrides && "temperature" in aiConfigOverrides ? aiConfigOverrides.temperature : resolved.temperature;
  const finalConfig = {
    stream: false,
    model: aiConfigOverrides?.model ?? x402.model ?? resolved.model,
    ...aiConfigOverrides ?? {},
    ...finalTemperature !== void 0 ? { temperature: finalTemperature } : {}
  };
  const finalOptions = {
    ...aiOptionOverrides ?? {},
    ...resolved.debug ? { debug: resolved.debug } : {}
  };
  const apiKey = aiOverrides.apiKey ?? resolved.apiKey ?? (typeof process !== "undefined" ? process.env.OPENAI_API_KEY : void 0);
  if (!apiKey) {
    throw new Error(
      "[agent-kit] createAxLLMClient requires an OpenAI API key (set apiKey or OPENAI_API_KEY)"
    );
  }
  const name = aiOverrides.name ?? resolved.provider;
  const apiURL = aiOverrides.apiURL ?? resolved.apiUrl;
  const finalAi = {
    ...aiOverrides,
    name,
    apiKey,
    ...apiURL ? { apiURL } : {},
    config: finalConfig,
    options: finalOptions
  };
  const createOptions = {
    ...x402,
    model: x402.model ?? resolved.model,
    ai: finalAi
  };
  if (!createOptions.account && !createOptions.privateKey) {
    const envPrivateKey = typeof process !== "undefined" ? process.env.PRIVATE_KEY : void 0;
    if (envPrivateKey) {
      createOptions.privateKey = envPrivateKey;
    }
  }
  return createOptions;
}
function readEnv(env) {
  if (env) return env;
  if (typeof process !== "undefined" && process?.env) {
    return process.env;
  }
  return {};
}
function parseBoolean(value) {
  if (value === void 0) return void 0;
  if (value.trim() === "") return void 0;
  return ["1", "true", "yes", "on"].includes(value.toLowerCase());
}
function parseNumber(value) {
  if (value === void 0) return void 0;
  const numeric = Number.parseFloat(value);
  return Number.isFinite(numeric) ? numeric : void 0;
}

// src/core/agent.ts
var AgentCore = class {
  constructor(config) {
    this.config = config;
    this.entrypoints = /* @__PURE__ */ new Map();
  }
  addEntrypoint(entrypoint) {
    if (!entrypoint.key || typeof entrypoint.key !== "string") {
      throw new Error("Entrypoint must include a non-empty string key");
    }
    this.entrypoints.set(entrypoint.key, entrypoint);
  }
  getEntrypoint(key) {
    return this.entrypoints.get(key);
  }
  listEntrypoints() {
    return Array.from(this.entrypoints.values());
  }
};
function createAgentCore(config) {
  return new AgentCore(config);
}
var AgentBuilder = class {
  constructor(meta) {
    this.meta = meta;
    this.extensions = [];
    this.entrypoints = [];
  }
  use(ext) {
    this.extensions.push(ext);
    return this;
  }
  addEntrypoint(def) {
    this.entrypoints.push(def);
    return this;
  }
  async build() {
    const agent = createAgentCore({
      meta: this.meta
    });
    const manifestCache = /* @__PURE__ */ new Map();
    const buildContext = {
      meta: this.meta,
      runtime: {}
    };
    const runtimeSlices = [];
    for (const ext of this.extensions) {
      try {
        const slice = ext.build(buildContext);
        runtimeSlices.push(slice);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        throw new Error(
          `Extension "${ext.name}" failed to build: ${errorMessage}`,
          { cause: error }
        );
      }
    }
    const mergedRuntime = {};
    const propertyOwners = /* @__PURE__ */ new Map();
    for (let i = 0; i < runtimeSlices.length; i++) {
      const slice = runtimeSlices[i];
      const extName = this.extensions[i]?.name ?? `extension-${i}`;
      for (const [key, value] of Object.entries(slice)) {
        if (key in mergedRuntime) {
          const owners = propertyOwners.get(key) ?? [];
          owners.push(extName);
          propertyOwners.set(key, owners);
          throw new Error(
            `Conflicting extensions: "${owners.join(
              '" and "'
            )}" both add "${key}" property to runtime. Extensions must not conflict.`
          );
        }
        mergedRuntime[key] = value;
        propertyOwners.set(key, [extName]);
      }
    }
    const snapshotEntrypoints = () => agent.listEntrypoints().map((entry) => ({
      ...entry,
      network: entry.network
    }));
    const listEntrypoints = () => snapshotEntrypoints().map((entry) => ({
      key: entry.key,
      description: entry.description,
      streaming: Boolean(entry.stream ?? entry.streaming)
    }));
    const runtime = {
      ...mergedRuntime,
      agent,
      entrypoints: {
        add: (def) => {
          if (!def.key) throw new Error("entrypoint.key required");
          for (const ext of this.extensions) {
            if (ext.onEntrypointAdded) {
              try {
                ext.onEntrypointAdded(def, runtime);
              } catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                throw new Error(
                  `Extension "${ext.name}" hook onEntrypointAdded failed: ${errorMessage}`,
                  { cause: error }
                );
              }
            }
          }
          agent.addEntrypoint(def);
          manifestCache.clear();
        },
        list: listEntrypoints,
        snapshot: snapshotEntrypoints
      },
      manifest: {
        build: (origin) => {
          const cached = manifestCache.get(origin);
          if (cached) {
            return cached;
          }
          let card;
          if (runtime.a2a) {
            card = runtime.a2a.buildCard(origin);
          } else {
            card = buildAgentCard({
              meta: this.meta,
              registry: snapshotEntrypoints(),
              origin
            });
          }
          for (const ext of this.extensions) {
            if (ext.onManifestBuild) {
              try {
                card = ext.onManifestBuild(card, runtime);
              } catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                throw new Error(
                  `Extension "${ext.name}" hook onManifestBuild failed: ${errorMessage}`,
                  { cause: error }
                );
              }
            }
          }
          manifestCache.set(origin, card);
          return card;
        },
        invalidate: () => {
          manifestCache.clear();
        }
      }
    };
    for (const entrypoint of this.entrypoints) {
      runtime.entrypoints.add(entrypoint);
    }
    const onBuildPromises = [];
    for (const ext of this.extensions) {
      if (ext.onBuild) {
        try {
          const result = ext.onBuild(runtime);
          if (result instanceof Promise) {
            onBuildPromises.push(
              result.catch((error) => {
                const errorMessage = error instanceof Error ? error.message : String(error);
                throw new Error(
                  `Extension "${ext.name}" hook onBuild failed: ${errorMessage}`,
                  { cause: error }
                );
              })
            );
          }
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          throw new Error(
            `Extension "${ext.name}" hook onBuild failed: ${errorMessage}`,
            { cause: error }
          );
        }
      }
    }
    if (onBuildPromises.length > 0) {
      await Promise.all(onBuildPromises);
    }
    return runtime;
  }
};

// src/runtime.ts
function createAgent(meta) {
  return new AgentBuilder(meta);
}

// src/utils/utils.ts
function hasDefinedValue(value) {
  if (!value) return false;
  return Object.values(value).some((entry) => {
    if (entry === void 0 || entry === null) return false;
    return typeof entry === "string" ? entry.trim().length > 0 : true;
  });
}

// src/validation.ts
function validateAgentMetadata(meta) {
  const missingFields = [];
  if (!meta.name) missingFields.push("name");
  if (!meta.version) missingFields.push("version");
  if (!meta.description) missingFields.push("description");
  if (missingFields.length > 0) {
    console.error(
      "[agent-kit] Required agent metadata is missing:",
      missingFields.join(", ")
    );
    throw new Error(
      `Missing required agent metadata: ${missingFields.join(", ")}. Please ensure AGENT_NAME, AGENT_VERSION, and AGENT_DESCRIPTION are set in your .env file.`
    );
  }
}

export { AgentBuilder, AgentCore, createAgent, createAgentCore, createAxLLMClient, hasDefinedValue, validateAgentMetadata };
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map