import { Hono } from 'hono';
import { paymentMiddleware } from 'x402-hono';
import { z } from 'zod';
import { resolvePrice, validatePaymentsConfig, extractSenderDomain, evaluateSender, extractPayerAddress, parsePriceAmount, findMostSpecificIncomingLimit } from '@lucid-agents/payments';

// src/app.ts
function withPayments({
  app,
  path,
  entrypoint,
  kind,
  payments,
  facilitator,
  middlewareFactory = paymentMiddleware,
  runtime
}) {
  if (!payments) return false;
  const network = entrypoint.network ?? payments.network;
  const price = resolvePrice(entrypoint, payments, kind);
  validatePaymentsConfig(payments, network, entrypoint.key);
  if (!price) return false;
  if (!payments.payTo) return false;
  const requestSchema = entrypoint.input ? z.toJSONSchema(entrypoint.input, { unrepresentable: "any" }) : void 0;
  const responseSchema = entrypoint.output ? z.toJSONSchema(entrypoint.output, { unrepresentable: "any" }) : void 0;
  const description = entrypoint.description ?? `${entrypoint.key}${kind === "stream" ? " (stream)" : ""}`;
  const postMimeType = kind === "stream" ? "text/event-stream" : "application/json";
  const inputSchema = {
    bodyType: "json",
    ...requestSchema ? { bodyFields: { input: requestSchema } } : {}
  };
  const outputSchema = kind === "invoke" && responseSchema ? { output: responseSchema } : void 0;
  const resolvedFacilitator = facilitator ?? { url: payments.facilitatorUrl };
  const postRoute = {
    price,
    network,
    config: {
      description,
      mimeType: postMimeType,
      discoverable: true,
      inputSchema,
      outputSchema
    }
  };
  const getRoute = {
    price,
    network,
    config: {
      description,
      mimeType: "application/json",
      discoverable: true,
      inputSchema,
      outputSchema
    }
  };
  const policyGroups = runtime?.payments?.policyGroups;
  const paymentTracker = runtime?.payments?.paymentTracker;
  if (policyGroups && policyGroups.length > 0) {
    app.use(path, async (c, next) => {
      const senderDomain = extractSenderDomain(
        c.req.header("origin"),
        c.req.header("referer")
      );
      for (const group of policyGroups) {
        if (group.blockedSenders || group.allowedSenders) {
          const result = evaluateSender(group, void 0, senderDomain);
          if (!result.allowed) {
            return c.json(
              {
                error: {
                  code: "policy_violation",
                  message: result.reason || "Payment blocked by policy",
                  groupName: result.groupName
                }
              },
              403
            );
          }
        }
      }
      await next();
    });
  }
  app.use(
    path,
    middlewareFactory(
      payments.payTo,
      {
        [`POST ${path}`]: postRoute,
        [`GET ${path}`]: getRoute
      },
      resolvedFacilitator
    )
  );
  if (policyGroups && policyGroups.length > 0 && paymentTracker) {
    app.use(path, async (c, next) => {
      await next();
      const paymentResponseHeader = c.res.headers.get("X-PAYMENT-RESPONSE");
      if (paymentResponseHeader && c.res.status >= 200 && c.res.status < 300) {
        try {
          const payerAddress = extractPayerAddress(paymentResponseHeader);
          const senderDomain = extractSenderDomain(
            c.req.header("origin"),
            c.req.header("referer")
          );
          const paymentAmount = parsePriceAmount(price);
          if (payerAddress && paymentAmount !== void 0) {
            for (const group of policyGroups) {
              if (group.incomingLimits) {
                const limitInfo = findMostSpecificIncomingLimit(
                  group.incomingLimits,
                  payerAddress,
                  senderDomain,
                  c.req.url
                );
                const scope = limitInfo?.scope ?? "global";
                await paymentTracker.recordIncoming(
                  group.name,
                  scope,
                  paymentAmount
                );
              }
            }
          }
        } catch (error) {
          console.error("[paywall] Error recording incoming payment:", error);
        }
      }
    });
  }
  return true;
}

// src/app.ts
async function createAgentApp(runtime, opts) {
  if (!runtime.handlers) {
    throw new Error(
      "HTTP extension is required. Use app.use(http()) when building the runtime."
    );
  }
  const app = new Hono();
  opts?.beforeMount?.(app);
  const registerEntrypointRoutes = (entrypoint) => {
    const invokePath = `/entrypoints/${entrypoint.key}/invoke`;
    const streamPath = `/entrypoints/${entrypoint.key}/stream`;
    withPayments({
      app,
      path: invokePath,
      entrypoint,
      kind: "invoke",
      payments: runtime.payments?.config,
      runtime
    });
    app.post(
      invokePath,
      (c) => runtime.handlers.invoke(c.req.raw, { key: entrypoint.key })
    );
    withPayments({
      app,
      path: streamPath,
      entrypoint,
      kind: "stream",
      payments: runtime.payments?.config,
      runtime
    });
    app.post(
      streamPath,
      (c) => runtime.handlers.stream(c.req.raw, { key: entrypoint.key })
    );
  };
  app.get("/health", (c) => runtime.handlers.health(c.req.raw));
  app.get("/entrypoints", (c) => runtime.handlers.entrypoints(c.req.raw));
  app.get("/.well-known/agent.json", (c) => runtime.handlers.manifest(c.req.raw));
  app.get(
    "/.well-known/agent-card.json",
    (c) => runtime.handlers.manifest(c.req.raw)
  );
  app.get("/favicon.svg", (c) => runtime.handlers.favicon(c.req.raw));
  app.post("/tasks", (c) => runtime.handlers.tasks(c.req.raw));
  app.get("/tasks", (c) => runtime.handlers.listTasks(c.req.raw));
  app.get(
    "/tasks/:taskId",
    (c) => runtime.handlers.getTask(c.req.raw, { taskId: c.req.param("taskId") })
  );
  app.post(
    "/tasks/:taskId/cancel",
    (c) => runtime.handlers.cancelTask(c.req.raw, { taskId: c.req.param("taskId") })
  );
  app.get(
    "/tasks/:taskId/subscribe",
    (c) => runtime.handlers.subscribeTask(c.req.raw, { taskId: c.req.param("taskId") })
  );
  if (runtime.handlers.landing) {
    app.get("/", (c) => runtime.handlers.landing(c.req.raw));
  } else {
    app.get("/", (c) => c.text("Landing disabled", 404));
  }
  const addEntrypoint = (def) => {
    runtime.entrypoints.add(def);
    const entrypoint = runtime.entrypoints.snapshot().find((item) => item.key === def.key);
    if (!entrypoint) {
      throw new Error(`Failed to register entrypoint "${def.key}"`);
    }
    registerEntrypointRoutes(entrypoint);
  };
  for (const entrypoint of runtime.entrypoints.snapshot()) {
    registerEntrypointRoutes(entrypoint);
  }
  opts?.afterMount?.(app);
  const result = {
    app,
    runtime,
    agent: runtime.agent,
    addEntrypoint
  };
  return result;
}

export { createAgentApp, withPayments };
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map