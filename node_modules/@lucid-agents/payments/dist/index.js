import { createSigner, wrapFetchWithPayment } from 'x402-fetch';
import { SupportedEVMNetworks, SupportedSVMNetworks } from 'x402/types';
import { mkdirSync, readFileSync } from 'fs';
import { dirname, join } from 'path';
import { Database } from 'bun:sqlite';
import { Pool } from 'pg';
import { ai } from '@ax-llm/ax';
import { privateKeyToAccount } from 'viem/accounts';
import { z } from 'zod';

var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/crypto.ts
function normalizeAddress(value) {
  if (!value) {
    throw new Error("invalid hex address");
  }
  const trimmed = value.trim();
  if (!/^0x[0-9a-fA-F]{40}$/.test(trimmed)) {
    throw new Error(`invalid hex address: ${value}`);
  }
  return trimmed.toLowerCase();
}
function sanitizeAddress(value) {
  if (!value) return ZERO_ADDRESS;
  const trimmed = value.trim();
  if (!/^0x[0-9a-fA-F]{40}$/.test(trimmed)) {
    return ZERO_ADDRESS;
  }
  return trimmed.toLowerCase();
}
var ZERO_ADDRESS;
var init_crypto = __esm({
  "src/crypto.ts"() {
    ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
  }
});

// src/policy.ts
function extractDomain(url) {
  try {
    const parsed = new URL(url);
    return parsed.hostname;
  } catch {
    return void 0;
  }
}
function normalizeUrl(url) {
  return url.trim().toLowerCase().replace(/\/+$/, "");
}
function formatUsdcAmount2(amount) {
  const usdc = Number(amount) / 1e6;
  return usdc.toFixed(6).replace(/\.?0+$/, "");
}
function extractDomainFromUrlOrDomain(urlOrDomain) {
  const domain = extractDomain(urlOrDomain);
  if (domain) {
    return domain.toLowerCase();
  }
  return normalizeUrl(urlOrDomain);
}
function domainsMatch(domain1, domain2) {
  const normalized1 = normalizeUrl(domain1);
  const normalized2 = normalizeUrl(domain2);
  if (normalized1 === normalized2) {
    return true;
  }
  if (normalized1.endsWith(`.${normalized2}`)) {
    return true;
  }
  return false;
}
function evaluateSender(group, senderAddress, senderDomain) {
  if (group.blockedSenders && group.blockedSenders.length > 0) {
    for (const blocked of group.blockedSenders) {
      const blockedDomain = extractDomainFromUrlOrDomain(blocked);
      const normalizedBlocked = normalizeUrl(blocked);
      if (senderAddress && normalizeUrl(senderAddress) === normalizedBlocked) {
        return {
          allowed: false,
          reason: `Sender address "${senderAddress}" is blocked by policy group "${group.name}"`,
          groupName: group.name
        };
      }
      if (senderDomain) {
        const normalizedDomain = normalizeUrl(senderDomain);
        if (domainsMatch(normalizedDomain, blockedDomain)) {
          return {
            allowed: false,
            reason: `Sender domain "${senderDomain}" is blocked by policy group "${group.name}"`,
            groupName: group.name
          };
        }
      }
    }
  }
  if (group.allowedSenders && group.allowedSenders.length > 0) {
    let isAllowed = false;
    for (const allowed of group.allowedSenders) {
      const allowedDomain = extractDomainFromUrlOrDomain(allowed);
      const normalizedAllowed = normalizeUrl(allowed);
      if (senderAddress && normalizeUrl(senderAddress) === normalizedAllowed) {
        isAllowed = true;
        break;
      }
      if (senderDomain) {
        const normalizedDomain = normalizeUrl(senderDomain);
        if (domainsMatch(normalizedDomain, allowedDomain)) {
          isAllowed = true;
          break;
        }
      }
    }
    if (!isAllowed) {
      return {
        allowed: false,
        reason: `Sender "${senderAddress || senderDomain || "unknown"}" is not in the whitelist for policy group "${group.name}"`,
        groupName: group.name
      };
    }
  }
  return { allowed: true };
}
function evaluateRecipient(group, recipientAddress, recipientDomain) {
  if (group.blockedRecipients && group.blockedRecipients.length > 0) {
    for (const blocked of group.blockedRecipients) {
      const blockedDomain = extractDomainFromUrlOrDomain(blocked);
      const normalizedBlocked = normalizeUrl(blocked);
      if (recipientAddress && normalizeUrl(recipientAddress) === normalizedBlocked) {
        return {
          allowed: false,
          reason: `Recipient address "${recipientAddress}" is blocked by policy group "${group.name}"`,
          groupName: group.name
        };
      }
      if (recipientDomain) {
        const normalizedDomain = normalizeUrl(recipientDomain);
        if (domainsMatch(normalizedDomain, blockedDomain)) {
          return {
            allowed: false,
            reason: `Recipient domain "${recipientDomain}" is blocked by policy group "${group.name}"`,
            groupName: group.name
          };
        }
      }
    }
  }
  if (group.allowedRecipients && group.allowedRecipients.length > 0) {
    let isAllowed = false;
    for (const allowed of group.allowedRecipients) {
      const allowedDomain = extractDomainFromUrlOrDomain(allowed);
      const normalizedAllowed = normalizeUrl(allowed);
      if (recipientAddress && normalizeUrl(recipientAddress) === normalizedAllowed) {
        isAllowed = true;
        break;
      }
      if (recipientDomain) {
        const normalizedDomain = normalizeUrl(recipientDomain);
        if (domainsMatch(normalizedDomain, allowedDomain)) {
          isAllowed = true;
          break;
        }
      }
    }
    if (!isAllowed) {
      return {
        allowed: false,
        reason: `Recipient "${recipientAddress || recipientDomain || "unknown"}" is not in the whitelist for policy group "${group.name}"`,
        groupName: group.name
      };
    }
  }
  return { allowed: true };
}
function evaluateRateLimit(group, rateLimiter) {
  if (!group.rateLimits) {
    return { allowed: true };
  }
  const { maxPayments, windowMs } = group.rateLimits;
  return rateLimiter.checkLimit(group.name, maxPayments, windowMs);
}
function findMostSpecificOutgoingLimit(limits, targetUrl, endpointUrl) {
  if (endpointUrl && limits.perEndpoint) {
    const normalizedEndpoint = normalizeUrl(endpointUrl);
    for (const [key, limit] of Object.entries(limits.perEndpoint)) {
      if (normalizeUrl(key) === normalizedEndpoint) {
        return { limit, scope: endpointUrl };
      }
    }
  }
  if (targetUrl && limits.perTarget) {
    const targetDomain = extractDomain(targetUrl);
    if (targetDomain) {
      const normalizedTarget = normalizeUrl(targetUrl);
      const normalizedDomain = normalizeUrl(targetDomain);
      for (const [key, limit] of Object.entries(limits.perTarget)) {
        const normalizedKey = normalizeUrl(key);
        const keyDomain = extractDomain(key);
        const normalizedKeyDomain = keyDomain ? normalizeUrl(keyDomain) : void 0;
        if (normalizedKey === normalizedTarget || normalizedKey === normalizedDomain || normalizedKeyDomain && normalizedKeyDomain === normalizedDomain || keyDomain && normalizeUrl(keyDomain) === normalizedDomain) {
          return { limit, scope: normalizedKey };
        }
      }
    }
  }
  if (limits.global) {
    return { limit: limits.global, scope: "global" };
  }
  return void 0;
}
function findMostSpecificIncomingLimit(limits, senderAddress, senderDomain, endpointUrl) {
  if (endpointUrl && limits.perEndpoint) {
    const normalizedEndpoint = normalizeUrl(endpointUrl);
    for (const [key, limit] of Object.entries(limits.perEndpoint)) {
      if (normalizeUrl(key) === normalizedEndpoint) {
        return { limit, scope: endpointUrl };
      }
    }
  }
  if (senderAddress && limits.perSender) {
    const normalizedSender = normalizeUrl(senderAddress);
    for (const [key, limit] of Object.entries(limits.perSender)) {
      if (normalizeUrl(key) === normalizedSender) {
        return { limit, scope: key };
      }
    }
  }
  if (senderDomain && limits.perSender) {
    const normalizedDomain = normalizeUrl(senderDomain);
    for (const [key, limit] of Object.entries(limits.perSender)) {
      const keyDomain = extractDomain(key);
      if (keyDomain && normalizeUrl(keyDomain) === normalizedDomain) {
        return { limit, scope: key };
      }
    }
  }
  if (limits.global) {
    return { limit: limits.global, scope: "global" };
  }
  return void 0;
}
async function evaluateOutgoingLimits(group, paymentTracker, targetUrl, endpointUrl, requestedAmount) {
  if (!group.outgoingLimits || requestedAmount === void 0) {
    return { allowed: true };
  }
  const limitInfo = findMostSpecificOutgoingLimit(
    group.outgoingLimits,
    targetUrl,
    endpointUrl
  );
  if (!limitInfo) {
    return { allowed: true };
  }
  const { limit, scope } = limitInfo;
  if (limit.maxPaymentUsd !== void 0) {
    const maxPaymentBaseUnits = BigInt(
      Math.floor(limit.maxPaymentUsd * 1e6)
    );
    if (requestedAmount > maxPaymentBaseUnits) {
      return {
        allowed: false,
        reason: `Per-request outgoing limit exceeded for policy group "${group.name}" at scope "${scope}". Requested: ${formatUsdcAmount2(requestedAmount)} USDC, Limit: ${limit.maxPaymentUsd} USDC`,
        groupName: group.name
      };
    }
  }
  if (limit.maxTotalUsd !== void 0) {
    const checkResult = await paymentTracker.checkOutgoingLimit(
      group.name,
      scope,
      limit.maxTotalUsd,
      limit.windowMs,
      requestedAmount
    );
    if (!checkResult.allowed) {
      return {
        allowed: false,
        reason: checkResult.reason,
        groupName: group.name
      };
    }
  }
  return { allowed: true };
}
async function evaluateIncomingLimits(group, paymentTracker, senderAddress, senderDomain, endpointUrl, requestedAmount) {
  if (!group.incomingLimits || requestedAmount === void 0) {
    return { allowed: true };
  }
  const limitInfo = findMostSpecificIncomingLimit(
    group.incomingLimits,
    senderAddress,
    senderDomain,
    endpointUrl
  );
  if (!limitInfo) {
    return { allowed: true };
  }
  const { limit, scope } = limitInfo;
  if (limit.maxPaymentUsd !== void 0) {
    const maxPaymentBaseUnits = BigInt(
      Math.floor(limit.maxPaymentUsd * 1e6)
    );
    if (requestedAmount > maxPaymentBaseUnits) {
      return {
        allowed: false,
        reason: `Per-request incoming limit exceeded for policy group "${group.name}" at scope "${scope}". Requested: ${formatUsdcAmount2(requestedAmount)} USDC, Limit: ${limit.maxPaymentUsd} USDC`,
        groupName: group.name
      };
    }
  }
  if (limit.maxTotalUsd !== void 0) {
    const checkResult = await paymentTracker.checkIncomingLimit(
      group.name,
      scope,
      limit.maxTotalUsd,
      limit.windowMs,
      requestedAmount
    );
    if (!checkResult.allowed) {
      return {
        allowed: false,
        reason: checkResult.reason,
        groupName: group.name
      };
    }
  }
  return { allowed: true };
}
async function evaluatePolicyGroups(groups, paymentTracker, rateLimiter, targetUrl, endpointUrl, requestedAmount, recipientAddress, recipientDomain) {
  if (targetUrl && !recipientDomain) {
    recipientDomain = extractDomain(targetUrl);
  }
  for (const group of groups) {
    const recipientResult = evaluateRecipient(
      group,
      recipientAddress,
      recipientDomain
    );
    if (!recipientResult.allowed) {
      return recipientResult;
    }
    const outgoingResult = await evaluateOutgoingLimits(
      group,
      paymentTracker,
      targetUrl,
      endpointUrl,
      requestedAmount
    );
    if (!outgoingResult.allowed) {
      return outgoingResult;
    }
    const rateResult = evaluateRateLimit(group, rateLimiter);
    if (!rateResult.allowed) {
      return rateResult;
    }
  }
  return { allowed: true };
}
async function evaluateIncomingPolicyGroups(groups, paymentTracker, senderAddress, senderDomain, endpointUrl, requestedAmount) {
  for (const group of groups) {
    const senderResult = evaluateSender(group, senderAddress, senderDomain);
    if (!senderResult.allowed) {
      return senderResult;
    }
    const incomingResult = await evaluateIncomingLimits(
      group,
      paymentTracker,
      senderAddress,
      senderDomain,
      endpointUrl,
      requestedAmount
    );
    if (!incomingResult.allowed) {
      return incomingResult;
    }
  }
  return { allowed: true };
}
var init_policy = __esm({
  "src/policy.ts"() {
  }
});

// src/policy-wrapper.ts
function getUrlString(input) {
  if (typeof input === "string") return input;
  if (input instanceof URL) return input.toString();
  if (input instanceof Request) return input.url;
  return String(input);
}
function extractDomain2(url) {
  try {
    const parsed = new URL(url);
    return parsed.hostname;
  } catch {
    return void 0;
  }
}
function parsePriceToBaseUnits(price) {
  if (!price) return void 0;
  try {
    const priceNum = parseFloat(price);
    if (!Number.isFinite(priceNum) || priceNum < 0) return void 0;
    return BigInt(Math.floor(priceNum * 1e6));
  } catch {
    return void 0;
  }
}
function extractPaymentAmount(response) {
  const priceHeader = response.headers.get("X-Price");
  return parsePriceToBaseUnits(priceHeader);
}
function extractRecipientAddress(request, response) {
  const payToHeader = response.headers.get("X-Pay-To");
  if (payToHeader) return payToHeader;
  return void 0;
}
function wrapBaseFetchWithPolicy(baseFetch, policyGroups, paymentTracker, rateLimiter) {
  const paymentInfoCache = /* @__PURE__ */ new Map();
  return async (input, init) => {
    const urlString = getUrlString(input);
    const targetUrl = urlString;
    const endpointUrl = urlString;
    const targetDomain = extractDomain2(urlString);
    const requestKey = `${urlString}:${init?.method || "GET"}`;
    const response = await baseFetch(input, init);
    if (response.status === 402) {
      const paymentAmount = extractPaymentAmount(response);
      const recipientAddress = extractRecipientAddress(
        input instanceof Request ? input : new Request(input, init),
        response
      );
      if (paymentAmount !== void 0) {
        const evaluation = await evaluatePolicyGroups(
          policyGroups,
          paymentTracker,
          rateLimiter,
          urlString,
          urlString,
          paymentAmount,
          recipientAddress || void 0,
          targetDomain
        );
        if (!evaluation.allowed) {
          return new Response(
            JSON.stringify({
              error: {
                code: "policy_violation",
                message: evaluation.reason || "Payment blocked by policy",
                groupName: evaluation.groupName
              }
            }),
            {
              status: 403,
              headers: {
                "Content-Type": "application/json"
              }
            }
          );
        }
        paymentInfoCache.set(requestKey, {
          amount: paymentAmount,
          recipientAddress: recipientAddress || void 0,
          recipientDomain: targetDomain
        });
      }
    }
    if (response.ok && response.status >= 200 && response.status < 300) {
      const paymentResponseHeader = response.headers.get("X-PAYMENT-RESPONSE");
      if (paymentResponseHeader) {
        const paymentInfo = paymentInfoCache.get(requestKey);
        if (paymentInfo) {
          for (const group of policyGroups) {
            if (group.outgoingLimits) {
              const limitInfo = findMostSpecificOutgoingLimit(
                group.outgoingLimits,
                targetUrl,
                endpointUrl
              );
              const scope = limitInfo?.scope ?? "global";
              await paymentTracker.recordOutgoing(
                group.name,
                scope,
                paymentInfo.amount
              );
            }
            if (group.rateLimits) {
              rateLimiter.recordPayment(group.name);
            }
          }
          paymentInfoCache.delete(requestKey);
        }
      }
    }
    return response;
  };
}
var init_policy_wrapper = __esm({
  "src/policy-wrapper.ts"() {
    init_policy();
  }
});

// src/runtime.ts
var runtime_exports = {};
__export(runtime_exports, {
  createRuntimePaymentContext: () => createRuntimePaymentContext
});
function logWarning(logger, message, ...args) {
  if (logger?.warn) {
    logger.warn(message, ...args);
    return;
  }
  console.warn(message, ...args);
}
function attachPreconnect(fetchImpl, baseFetch) {
  const upstream = baseFetch;
  const fallbackPreconnect = async () => {
  };
  const preconnectFn = typeof upstream.preconnect === "function" ? upstream.preconnect.bind(baseFetch) : fallbackPreconnect;
  fetchImpl.preconnect = preconnectFn;
  return fetchImpl;
}
function inferChainId(network) {
  if (!network) return void 0;
  const normalized = network.toLowerCase();
  if (normalized === "base" || normalized === "eip155:8453") return 8453;
  if (normalized === "base-sepolia" || normalized === "eip155:84532" || normalized === "base_testnet")
    return 84532;
  return void 0;
}
function normalizeTypedData(input) {
  if (!input.primaryType) {
    throw new Error("[agent-kit] Typed data missing primaryType");
  }
  return {
    domain: input.domain ?? {},
    types: input.types ?? {},
    message: input.message ?? {},
    primaryType: input.primaryType
  };
}
async function fetchWalletAddress(wallet) {
  try {
    const metadata = await wallet.getWalletMetadata();
    return metadata?.address ?? null;
  } catch {
    return null;
  }
}
function resolveMaxPaymentBaseUnits(override, configOverride) {
  if (typeof override === "bigint") return override;
  return void 0;
}
function createRuntimeSigner(opts) {
  let currentAddress = normalizeAddressOrNull(opts.initialAddress);
  let currentChainId = opts.chainId;
  const signer = {
    chain: { id: currentChainId },
    account: { address: currentAddress },
    transport: { type: "agent-runtime" },
    async signTypedData(data) {
      const typedData = normalizeTypedData(data);
      const domainChain = typedData.domain?.chainId ?? typedData.domain?.chain_id;
      if (typeof domainChain !== "undefined") {
        const parsed = Number(domainChain);
        if (Number.isFinite(parsed) && parsed > 0) {
          currentChainId = parsed;
          signer.chain.id = parsed;
        }
      }
      const challengePayload = {
        typedData: {
          domain: typedData.domain,
          types: typedData.types,
          message: typedData.message,
          primaryType: typedData.primaryType
        }
      };
      const challenge = {
        id: typeof crypto?.randomUUID === "function" ? crypto.randomUUID() : globalThis?.crypto?.randomUUID ? globalThis.crypto.randomUUID() : `${Date.now()}-${Math.random()}`,
        nonce: `${Date.now()}-${Math.random()}`,
        issued_at: (/* @__PURE__ */ new Date()).toISOString(),
        expires_at: new Date(Date.now() + 36e5).toISOString(),
        payload: challengePayload,
        scopes: ["wallet.sign"]
      };
      const signature = await opts.wallet.signChallenge(challenge);
      const metadata = await opts.wallet.getWalletMetadata();
      if (metadata?.address) {
        const nextAddress = normalizeAddressOrNull(metadata.address);
        currentAddress = nextAddress ?? currentAddress;
        signer.account.address = currentAddress;
      }
      return signature;
    },
    async signMessage(message) {
      const payload = toStringMessage(message);
      const challengePayload = payload;
      const challenge = {
        id: typeof crypto?.randomUUID === "function" ? crypto.randomUUID() : globalThis?.crypto?.randomUUID ? globalThis.crypto.randomUUID() : `${Date.now()}-${Math.random()}`,
        nonce: `${Date.now()}-${Math.random()}`,
        issued_at: (/* @__PURE__ */ new Date()).toISOString(),
        expires_at: new Date(Date.now() + 36e5).toISOString(),
        payload: challengePayload,
        scopes: ["wallet.sign"]
      };
      const signature = await opts.wallet.signChallenge(challenge);
      const metadata = await opts.wallet.getWalletMetadata();
      if (metadata?.address) {
        const nextAddress = normalizeAddressOrNull(metadata.address);
        currentAddress = nextAddress ?? currentAddress;
        signer.account.address = currentAddress;
      }
      return signature;
    }
  };
  return signer;
}
async function createRuntimePaymentContext(options) {
  const baseFetch = options.fetch ?? globalThis.fetch;
  if (!baseFetch) {
    logWarning(
      options.logger,
      "[agent-kit] No fetch implementation available; skipping payment wrapping"
    );
    return {
      fetchWithPayment: null,
      signer: null,
      walletAddress: null,
      chainId: null
    };
  }
  if (options.privateKey) {
    if (!options.network) {
      logWarning(
        options.logger,
        "[agent-kit-payments] Private key payment context requires options.network"
      );
      return {
        fetchWithPayment: null,
        signer: null,
        walletAddress: null,
        chainId: null
      };
    }
    try {
      const signer2 = await createSigner(
        options.network,
        options.privateKey
      );
      const fetchWithPayment = attachPreconnect(
        wrapFetchWithPayment(
          baseFetch,
          signer2,
          resolveMaxPaymentBaseUnits(options.maxPaymentBaseUnits)
        ),
        baseFetch
      );
      return {
        fetchWithPayment,
        signer: signer2,
        walletAddress: normalizeAddressOrNull(
          signer2?.account?.address
        ),
        chainId: typeof signer2?.chain?.id === "number" ? signer2.chain.id : null
      };
    } catch (error) {
      logWarning(
        options.logger,
        `[agent-kit-payments] Failed to initialise paid fetch with private key: ${error?.message ?? error}`
      );
      return {
        fetchWithPayment: null,
        signer: null,
        walletAddress: null,
        chainId: null
      };
    }
  }
  if (!options.runtime) {
    logWarning(
      options.logger,
      "[agent-kit-payments] Runtime payment context requires either a runtime or private key"
    );
    return {
      fetchWithPayment: null,
      signer: null,
      walletAddress: null,
      chainId: null
    };
  }
  const runtime = options.runtime;
  if (!runtime.wallets?.agent) {
    logWarning(
      options.logger,
      "[agent-kit-payments] Runtime does not have an agent wallet configured"
    );
    return {
      fetchWithPayment: null,
      signer: null,
      walletAddress: null,
      chainId: null
    };
  }
  const wallet = runtime.wallets.agent;
  const chainId = options.chainId ?? inferChainId(options.network);
  if (!chainId) {
    logWarning(
      options.logger,
      "[agent-kit-payments] Unable to derive chainId for runtime payments; provide options.chainId or options.network"
    );
    return {
      fetchWithPayment: null,
      signer: null,
      walletAddress: null,
      chainId: null
    };
  }
  const walletAddress = await fetchWalletAddress(wallet.connector);
  const signer = createRuntimeSigner({
    wallet: wallet.connector,
    initialAddress: walletAddress,
    chainId
  });
  try {
    let fetchWithPolicy = baseFetch;
    const policyGroups = runtime.payments?.policyGroups;
    const paymentTracker = runtime.payments?.paymentTracker;
    const rateLimiter = runtime.payments?.rateLimiter;
    if (policyGroups && policyGroups.length > 0 && paymentTracker && rateLimiter) {
      fetchWithPolicy = wrapBaseFetchWithPolicy(
        baseFetch,
        policyGroups,
        paymentTracker,
        rateLimiter
      );
    }
    const fetchWithPayment = attachPreconnect(
      wrapFetchWithPayment(
        fetchWithPolicy,
        signer,
        resolveMaxPaymentBaseUnits(options.maxPaymentBaseUnits)
      ),
      baseFetch
    );
    return {
      fetchWithPayment,
      signer,
      walletAddress: signer.account.address,
      chainId
    };
  } catch (error) {
    logWarning(
      options.logger,
      `[agent-kit-payments] Failed to initialise runtime-backed paid fetch: ${error?.message ?? error}`
    );
    return {
      fetchWithPayment: null,
      signer: null,
      walletAddress: normalizeAddressOrNull(walletAddress),
      chainId
    };
  }
}
var toStringMessage, normalizeAddressOrNull;
var init_runtime = __esm({
  "src/runtime.ts"() {
    init_crypto();
    init_policy_wrapper();
    toStringMessage = (message) => {
      if (typeof message === "string") return message;
      if (typeof message?.raw === "string") {
        return String(message.raw);
      }
      if (message instanceof Uint8Array) {
        return Array.from(message).map((byte) => byte.toString(16).padStart(2, "0")).join("");
      }
      if (typeof message === "object") {
        return JSON.stringify(message ?? "");
      }
      return String(message ?? "");
    };
    normalizeAddressOrNull = (value) => {
      const sanitized = sanitizeAddress(value ?? void 0);
      return sanitized === ZERO_ADDRESS ? null : sanitized;
    };
  }
});

// src/pricing.ts
function resolvePrice(entrypoint, payments2, which) {
  if (!entrypoint.price) {
    return null;
  } else if (typeof entrypoint.price === "string") {
    return entrypoint.price;
  } else {
    return entrypoint.price[which] ?? null;
  }
}

// src/manifest.ts
function createAgentCardWithPayments(card, paymentsConfig, entrypoints) {
  const entrypointList = Array.from(entrypoints);
  const entrypointsWithPricing = {};
  for (const [key, entrypoint] of Object.entries(card.entrypoints)) {
    const entrypointDef = entrypointList.find((e) => e.key === key);
    if (!entrypointDef) {
      entrypointsWithPricing[key] = entrypoint;
      continue;
    }
    const invP = resolvePrice(entrypointDef, paymentsConfig, "invoke");
    const strP = entrypointDef.stream ? resolvePrice(entrypointDef, paymentsConfig, "stream") : void 0;
    const manifestEntry = {
      ...entrypoint
    };
    if (invP || strP) {
      const pricing = {};
      if (invP) pricing.invoke = invP;
      if (strP) pricing.stream = strP;
      manifestEntry.pricing = pricing;
    }
    entrypointsWithPricing[key] = manifestEntry;
  }
  const paymentMethod = {
    method: "x402",
    payee: paymentsConfig.payTo,
    network: paymentsConfig.network,
    endpoint: paymentsConfig.facilitatorUrl,
    extensions: {
      x402: { facilitatorUrl: paymentsConfig.facilitatorUrl }
    }
  };
  return {
    ...card,
    entrypoints: entrypointsWithPricing,
    payments: [paymentMethod]
  };
}
var SUPPORTED_NETWORKS = [
  ...SupportedEVMNetworks,
  ...SupportedSVMNetworks
];
function validatePaymentsConfig(payments2, network, entrypointKey) {
  if (!payments2.payTo) {
    console.error(
      `[agent-kit] Payment configuration error for entrypoint "${entrypointKey}":`,
      "PAYMENTS_RECEIVABLE_ADDRESS is not set.",
      "Please set the environment variable or configure payments.payTo in your agent setup."
    );
    throw new Error(
      `Payment configuration error: PAYMENTS_RECEIVABLE_ADDRESS environment variable is not set. This is required to receive payments. Please set PAYMENTS_RECEIVABLE_ADDRESS to your wallet address.`
    );
  }
  if (!payments2.facilitatorUrl) {
    console.error(
      `[agent-kit] Payment configuration error for entrypoint "${entrypointKey}":`,
      "FACILITATOR_URL is not set.",
      "Please set the environment variable or configure payments.facilitatorUrl."
    );
    throw new Error(
      `Payment configuration error: FACILITATOR_URL environment variable is not set. This is required for payment processing.`
    );
  }
  if (!network) {
    console.error(
      `[agent-kit] Payment configuration error for entrypoint "${entrypointKey}":`,
      "NETWORK is not set.",
      "Please set the NETWORK environment variable or configure payments.network."
    );
    throw new Error(
      `Payment configuration error: NETWORK is not set. This is required for payment processing.`
    );
  }
  if (!SUPPORTED_NETWORKS.includes(network)) {
    console.error(
      `[agent-kit] Payment configuration error for entrypoint "${entrypointKey}":`,
      `Unsupported network: ${network}`,
      `Supported networks: ${SUPPORTED_NETWORKS.join(", ")}`
    );
    throw new Error(
      `Unsupported payment network: ${network}. Supported networks: ${SUPPORTED_NETWORKS.join(", ")}. Please use one of the supported networks in your configuration.`
    );
  }
}
var SQLitePaymentStorage = class {
  constructor(dbPath, agentId) {
    if (typeof Bun === "undefined") {
      throw new Error(
        "SQLitePaymentStorage requires Bun runtime. Use PostgresPaymentStorage or InMemoryPaymentStorage for Node.js."
      );
    }
    const path = dbPath ?? ".data/payments.db";
    const dir = dirname(path);
    if (dir && dir !== ".") {
      try {
        mkdirSync(dir, { recursive: true });
      } catch (error) {
      }
    }
    this.db = new Database(path);
    this.initSchema();
  }
  initSchema() {
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS payments (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        agent_id TEXT,
        group_name TEXT NOT NULL,
        scope TEXT NOT NULL,
        direction TEXT NOT NULL,
        amount TEXT NOT NULL,
        timestamp INTEGER NOT NULL
      );
      CREATE INDEX IF NOT EXISTS idx_agent_group_scope ON payments(agent_id, group_name, scope) WHERE agent_id IS NOT NULL;
      CREATE INDEX IF NOT EXISTS idx_group_scope ON payments(group_name, scope);
      CREATE INDEX IF NOT EXISTS idx_timestamp ON payments(timestamp);
      CREATE INDEX IF NOT EXISTS idx_direction ON payments(direction);
    `);
  }
  async recordPayment(record) {
    const stmt = this.db.prepare(`
      INSERT INTO payments (group_name, scope, direction, amount, timestamp)
      VALUES (?, ?, ?, ?, ?)
    `);
    stmt.run(
      record.groupName,
      record.scope,
      record.direction,
      record.amount.toString(),
      Date.now()
    );
    return Promise.resolve();
  }
  async getTotal(groupName, scope, direction, windowMs) {
    let query = `
      SELECT amount
      FROM payments
      WHERE group_name = ? AND scope = ? AND direction = ?
    `;
    let stmt;
    if (windowMs !== void 0) {
      query += " AND timestamp > ?";
      stmt = this.db.prepare(query);
      const rows = stmt.all(
        groupName,
        scope,
        direction,
        Date.now() - windowMs
      );
      const total = rows.reduce((sum, row) => sum + BigInt(row.amount), 0n);
      return Promise.resolve(total);
    } else {
      stmt = this.db.prepare(query);
      const rows = stmt.all(groupName, scope, direction);
      const total = rows.reduce((sum, row) => sum + BigInt(row.amount), 0n);
      return Promise.resolve(total);
    }
  }
  async getAllRecords(groupName, scope, direction, windowMs) {
    let query = "SELECT * FROM payments WHERE 1=1";
    const conditions = [];
    const params = [];
    if (groupName) {
      conditions.push("group_name = ?");
      params.push(groupName);
    }
    if (scope) {
      conditions.push("scope = ?");
      params.push(scope);
    }
    if (direction) {
      conditions.push("direction = ?");
      params.push(direction);
    }
    if (windowMs !== void 0) {
      conditions.push("timestamp > ?");
      params.push(Date.now() - windowMs);
    }
    if (conditions.length > 0) {
      query += " AND " + conditions.join(" AND ");
    }
    query += " ORDER BY timestamp DESC";
    const stmt = this.db.prepare(query);
    let result;
    if (params.length === 0) {
      result = stmt.all();
    } else if (params.length === 1) {
      result = stmt.all(params[0]);
    } else if (params.length === 2) {
      result = stmt.all(params[0], params[1]);
    } else if (params.length === 3) {
      result = stmt.all(params[0], params[1], params[2]);
    } else {
      result = stmt.all(params[0], params[1], params[2], params[3]);
    }
    const rows = result;
    return Promise.resolve(
      rows.map((row) => ({
        id: row.id,
        groupName: row.group_name,
        scope: row.scope,
        direction: row.direction,
        amount: BigInt(row.amount),
        timestamp: row.timestamp
      }))
    );
  }
  async clear() {
    this.db.exec("DELETE FROM payments");
    return Promise.resolve();
  }
  /**
   * Closes the database connection.
   * Should be called when the storage is no longer needed.
   */
  close() {
    this.db.close();
  }
};
function createSQLitePaymentStorage(dbPath, agentId) {
  return new SQLitePaymentStorage(dbPath, agentId);
}

// src/payment-tracker.ts
function formatUsdcAmount(amount) {
  const usdc = Number(amount) / 1e6;
  return usdc.toFixed(6).replace(/\.?0+$/, "");
}
var PaymentTracker = class {
  constructor(storage) {
    this.storage = storage;
  }
  /**
   * Checks if an outgoing payment limit would be exceeded.
   * @param groupName - Policy group name
   * @param scope - Scope key ("global", target URL, or endpoint URL)
   * @param maxTotalUsd - Maximum total spending in USD
   * @param windowMs - Optional time window in milliseconds (if not provided, lifetime limit)
   * @param requestedAmount - Amount requested in base units (USDC has 6 decimals)
   * @returns Result indicating if allowed and current total
   */
  async checkOutgoingLimit(groupName, scope, maxTotalUsd, windowMs, requestedAmount) {
    const maxTotalBaseUnits = BigInt(Math.floor(maxTotalUsd * 1e6));
    const currentTotal = await this.storage.getTotal(
      groupName,
      scope,
      "outgoing",
      windowMs
    );
    const newTotal = currentTotal + requestedAmount;
    if (newTotal > maxTotalBaseUnits) {
      return {
        allowed: false,
        reason: `Total outgoing payment limit exceeded for policy group "${groupName}" at scope "${scope}". Current: ${formatUsdcAmount(currentTotal)} USDC, Requested: ${formatUsdcAmount(requestedAmount)} USDC, Limit: ${maxTotalUsd} USDC`,
        currentTotal
      };
    }
    return {
      allowed: true,
      currentTotal
    };
  }
  /**
   * Checks if an incoming payment limit would be exceeded.
   * @param groupName - Policy group name
   * @param scope - Scope key ("global", sender address, or endpoint URL)
   * @param maxTotalUsd - Maximum total incoming in USD
   * @param windowMs - Optional time window in milliseconds (if not provided, lifetime limit)
   * @param requestedAmount - Amount requested in base units (USDC has 6 decimals)
   * @returns Result indicating if allowed and current total
   */
  async checkIncomingLimit(groupName, scope, maxTotalUsd, windowMs, requestedAmount) {
    const maxTotalBaseUnits = BigInt(Math.floor(maxTotalUsd * 1e6));
    const currentTotal = await this.storage.getTotal(
      groupName,
      scope,
      "incoming",
      windowMs
    );
    const newTotal = currentTotal + requestedAmount;
    if (newTotal > maxTotalBaseUnits) {
      return {
        allowed: false,
        reason: `Total incoming payment limit exceeded for policy group "${groupName}" at scope "${scope}". Current: ${formatUsdcAmount(currentTotal)} USDC, Requested: ${formatUsdcAmount(requestedAmount)} USDC, Limit: ${maxTotalUsd} USDC`,
        currentTotal
      };
    }
    return {
      allowed: true,
      currentTotal
    };
  }
  /**
   * Records an outgoing payment after a successful payment.
   * @param groupName - Policy group name
   * @param scope - Scope key ("global", target URL, or endpoint URL)
   * @param amount - Amount spent in base units
   */
  async recordOutgoing(groupName, scope, amount) {
    await this.storage.recordPayment({
      groupName,
      scope,
      direction: "outgoing",
      amount
    });
  }
  /**
   * Records an incoming payment after a successful payment.
   * @param groupName - Policy group name
   * @param scope - Scope key ("global", sender address, or endpoint URL)
   * @param amount - Amount received in base units
   */
  async recordIncoming(groupName, scope, amount) {
    await this.storage.recordPayment({
      groupName,
      scope,
      direction: "incoming",
      amount
    });
  }
  /**
   * Gets the current total outgoing payments for a scope (for informational purposes).
   * @param groupName - Policy group name
   * @param scope - Scope key
   * @param windowMs - Optional time window to filter entries
   * @returns Current total in base units
   */
  async getOutgoingTotal(groupName, scope, windowMs) {
    return await this.storage.getTotal(groupName, scope, "outgoing", windowMs);
  }
  /**
   * Gets the current total incoming payments for a scope (for informational purposes).
   * @param groupName - Policy group name
   * @param scope - Scope key
   * @param windowMs - Optional time window to filter entries
   * @returns Current total in base units
   */
  async getIncomingTotal(groupName, scope, windowMs) {
    return await this.storage.getTotal(groupName, scope, "incoming", windowMs);
  }
  /**
   * Gets all payment data (both outgoing and incoming).
   * @returns Array of all payment records
   */
  async getAllData() {
    return await this.storage.getAllRecords();
  }
  /**
   * Clears all payment data (useful for testing or reset).
   */
  async clear() {
    await this.storage.clear();
  }
};
function createPaymentTracker(storage) {
  const storageImpl = storage ?? createSQLitePaymentStorage();
  return new PaymentTracker(storageImpl);
}

// src/rate-limiter.ts
var RateLimiter = class {
  constructor() {
    this.payments = /* @__PURE__ */ new Map();
  }
  /**
   * Checks if a payment would exceed the rate limit.
   * @param groupName - Policy group name
   * @param maxPayments - Maximum number of payments allowed
   * @param windowMs - Time window in milliseconds
   * @returns Result indicating if allowed
   */
  checkLimit(groupName, maxPayments, windowMs) {
    const now = Date.now();
    const cutoff = now - windowMs;
    let timestamps = this.payments.get(groupName);
    if (!timestamps) {
      timestamps = [];
      this.payments.set(groupName, timestamps);
    }
    const validTimestamps = timestamps.filter((ts) => ts > cutoff);
    this.payments.set(groupName, validTimestamps);
    if (validTimestamps.length >= maxPayments) {
      return {
        allowed: false,
        reason: `Rate limit exceeded for policy group "${groupName}". ${validTimestamps.length} payments in the last ${windowMs}ms, limit is ${maxPayments}`
      };
    }
    return { allowed: true };
  }
  /**
   * Records a payment after successful execution.
   * @param groupName - Policy group name
   */
  recordPayment(groupName) {
    const now = Date.now();
    let timestamps = this.payments.get(groupName);
    if (!timestamps) {
      timestamps = [];
      this.payments.set(groupName, timestamps);
    }
    timestamps.push(now);
  }
  /**
   * Gets the current count of payments within the window (for informational purposes).
   * @param groupName - Policy group name
   * @param windowMs - Time window in milliseconds
   * @returns Current count of payments
   */
  getCurrentCount(groupName, windowMs) {
    const now = Date.now();
    const cutoff = now - windowMs;
    const timestamps = this.payments.get(groupName);
    if (!timestamps) {
      return 0;
    }
    return timestamps.filter((ts) => ts > cutoff).length;
  }
  /**
   * Clears all rate limit data (useful for testing or reset).
   */
  clear() {
    this.payments.clear();
  }
};
function createRateLimiter() {
  return new RateLimiter();
}

// src/in-memory-payment-storage.ts
var InMemoryPaymentStorage = class {
  constructor() {
    this.payments = /* @__PURE__ */ new Map();
  }
  async recordPayment(record) {
    const key = `${record.groupName}:${record.direction}`;
    let groupPayments = this.payments.get(key);
    if (!groupPayments) {
      groupPayments = /* @__PURE__ */ new Map();
      this.payments.set(key, groupPayments);
    }
    let entries = groupPayments.get(record.scope);
    if (!entries) {
      entries = [];
      groupPayments.set(record.scope, entries);
    }
    entries.push({
      amount: record.amount,
      timestamp: Date.now()
    });
    return Promise.resolve();
  }
  async getTotal(groupName, scope, direction, windowMs) {
    const key = `${groupName}:${direction}`;
    const groupPayments = this.payments.get(key);
    if (!groupPayments) {
      return Promise.resolve(0n);
    }
    let entries = groupPayments.get(scope);
    if (!entries || entries.length === 0) {
      return Promise.resolve(0n);
    }
    if (windowMs !== void 0) {
      const cutoff = Date.now() - windowMs;
      entries = entries.filter((entry) => entry.timestamp > cutoff);
    }
    return Promise.resolve(
      entries.reduce((sum, entry) => sum + entry.amount, 0n)
    );
  }
  async getAllRecords(groupName, scope, direction, windowMs) {
    const records = [];
    const cutoff = windowMs !== void 0 ? Date.now() - windowMs : void 0;
    for (const [key, groupPayments] of this.payments.entries()) {
      const lastColonIndex = key.lastIndexOf(":");
      if (lastColonIndex === -1) {
        continue;
      }
      const keyGroupName = key.substring(0, lastColonIndex);
      const keyDirection = key.substring(
        lastColonIndex + 1
      );
      if (groupName && keyGroupName !== groupName) {
        continue;
      }
      if (direction && keyDirection !== direction) {
        continue;
      }
      for (const [keyScope, entries] of groupPayments.entries()) {
        if (scope && keyScope !== scope) {
          continue;
        }
        const filteredEntries = cutoff !== void 0 ? entries.filter((entry) => entry.timestamp > cutoff) : entries;
        for (const entry of filteredEntries) {
          records.push({
            groupName: keyGroupName,
            scope: keyScope,
            direction: keyDirection,
            amount: entry.amount,
            timestamp: entry.timestamp
          });
        }
      }
    }
    return Promise.resolve(records);
  }
  async clear() {
    this.payments.clear();
    return Promise.resolve();
  }
};
function createInMemoryPaymentStorage() {
  return new InMemoryPaymentStorage();
}
var PostgresPaymentStorage = class {
  constructor(connectionString, agentId) {
    this.schemaInitialized = false;
    this.pool = new Pool({
      connectionString,
      max: 10,
      idleTimeoutMillis: 3e4,
      connectionTimeoutMillis: 5e3
    });
    this.agentId = agentId;
  }
  async initSchema() {
    if (this.schemaInitialized) {
      return;
    }
    const client = await this.pool.connect();
    try {
      await client.query(`
        CREATE TABLE IF NOT EXISTS payments (
          id SERIAL PRIMARY KEY,
          agent_id TEXT,
          group_name VARCHAR NOT NULL,
          scope VARCHAR NOT NULL,
          direction VARCHAR NOT NULL,
          amount BIGINT NOT NULL,
          timestamp BIGINT NOT NULL
        );
        CREATE INDEX IF NOT EXISTS idx_agent_group_scope ON payments(agent_id, group_name, scope) WHERE agent_id IS NOT NULL;
        CREATE INDEX IF NOT EXISTS idx_group_scope ON payments(group_name, scope);
        CREATE INDEX IF NOT EXISTS idx_timestamp ON payments(timestamp);
        CREATE INDEX IF NOT EXISTS idx_direction ON payments(direction);
      `);
      this.schemaInitialized = true;
    } finally {
      client.release();
    }
  }
  async recordPayment(record) {
    if (!this.schemaInitialized) {
      await this.initSchema();
    }
    try {
      if (this.agentId) {
        await this.pool.query(
          `
          INSERT INTO payments (agent_id, group_name, scope, direction, amount, timestamp)
          VALUES ($1, $2, $3, $4, $5, $6)
        `,
          [
            this.agentId,
            record.groupName,
            record.scope,
            record.direction,
            record.amount.toString(),
            Date.now()
          ]
        );
      } else {
        await this.pool.query(
          `
          INSERT INTO payments (agent_id, group_name, scope, direction, amount, timestamp)
          VALUES (NULL, $1, $2, $3, $4, $5)
        `,
          [
            record.groupName,
            record.scope,
            record.direction,
            record.amount.toString(),
            Date.now()
          ]
        );
      }
    } catch (error) {
      console.error("[PostgresPaymentStorage] Error recording payment:", error);
      throw error;
    }
  }
  async getTotal(groupName, scope, direction, windowMs) {
    try {
      if (!this.schemaInitialized) {
        await this.initSchema();
      }
      let query;
      const params = [];
      let paramIndex = 1;
      if (this.agentId) {
        query = `
          SELECT SUM(amount) as total
          FROM payments
          WHERE agent_id = $${paramIndex} AND group_name = $${paramIndex + 1} AND scope = $${paramIndex + 2} AND direction = $${paramIndex + 3}
        `;
        params.push(this.agentId, groupName, scope, direction);
        paramIndex += 4;
      } else {
        query = `
          SELECT SUM(amount) as total
          FROM payments
          WHERE agent_id IS NULL AND group_name = $${paramIndex} AND scope = $${paramIndex + 1} AND direction = $${paramIndex + 2}
        `;
        params.push(groupName, scope, direction);
        paramIndex += 3;
      }
      if (windowMs !== void 0) {
        query += ` AND timestamp > $${paramIndex}`;
        params.push(Date.now() - windowMs);
      }
      const queryResult = await this.pool.query(query, params);
      const total = queryResult.rows[0]?.total;
      return total ? BigInt(total) : 0n;
    } catch (error) {
      console.error("[PostgresPaymentStorage] Error getting total:", error);
      return 0n;
    }
  }
  async getAllRecords(groupName, scope, direction, windowMs) {
    try {
      if (!this.schemaInitialized) {
        await this.initSchema();
      }
      let query = "SELECT * FROM payments WHERE 1=1";
      const params = [];
      let paramIndex = 1;
      if (this.agentId) {
        query += ` AND agent_id = $${paramIndex}`;
        params.push(this.agentId);
        paramIndex++;
      } else {
        query += ` AND agent_id IS NULL`;
      }
      if (groupName) {
        query += ` AND group_name = $${paramIndex}`;
        params.push(groupName);
        paramIndex++;
      }
      if (scope) {
        query += ` AND scope = $${paramIndex}`;
        params.push(scope);
        paramIndex++;
      }
      if (direction) {
        query += ` AND direction = $${paramIndex}`;
        params.push(direction);
        paramIndex++;
      }
      if (windowMs !== void 0) {
        query += ` AND timestamp > $${paramIndex}`;
        params.push(Date.now() - windowMs);
        paramIndex++;
      }
      query += " ORDER BY timestamp DESC";
      const queryResult = await this.pool.query(query, params);
      return queryResult.rows.map((row) => ({
        id: row.id,
        groupName: row.group_name,
        scope: row.scope,
        direction: row.direction,
        amount: BigInt(row.amount),
        timestamp: Number(row.timestamp)
      }));
    } catch (error) {
      console.error("[PostgresPaymentStorage] Error getting records:", error);
      return [];
    }
  }
  async clear() {
    try {
      if (!this.schemaInitialized) {
        await this.initSchema();
      }
      if (this.agentId) {
        await this.pool.query("DELETE FROM payments WHERE agent_id = $1", [
          this.agentId
        ]);
      } else {
        await this.pool.query("DELETE FROM payments");
      }
    } catch (error) {
      console.error("[PostgresPaymentStorage] Error clearing payments:", error);
      throw error;
    }
  }
  /**
   * Closes the connection pool.
   * Should be called when the storage is no longer needed.
   */
  async close() {
    await this.pool.end();
  }
};
function createPostgresPaymentStorage(connectionString, agentId) {
  return new PostgresPaymentStorage(connectionString, agentId);
}

// src/payments.ts
function entrypointHasExplicitPrice(entrypoint) {
  const { price } = entrypoint;
  if (typeof price === "string") {
    return price.trim().length > 0;
  }
  if (price && typeof price === "object") {
    const hasInvoke = price.invoke;
    const hasStream = price.stream;
    const invokeDefined = typeof hasInvoke === "string" ? hasInvoke.trim().length > 0 : hasInvoke !== void 0;
    const streamDefined = typeof hasStream === "string" ? hasStream.trim().length > 0 : hasStream !== void 0;
    return invokeDefined || streamDefined;
  }
  return false;
}
function resolveActivePayments(entrypoint, paymentsOption, resolvedPayments, currentActivePayments) {
  if (paymentsOption === false) {
    return void 0;
  }
  if (currentActivePayments) {
    return currentActivePayments;
  }
  if (!entrypointHasExplicitPrice(entrypoint)) {
    return void 0;
  }
  if (!resolvedPayments) {
    return void 0;
  }
  return { ...resolvedPayments };
}
function evaluatePaymentRequirement(entrypoint, kind, activePayments) {
  const requirement = resolvePaymentRequirement(
    entrypoint,
    kind,
    activePayments
  );
  if (requirement.required) {
    const requiredRequirement = requirement;
    const enriched = {
      ...requiredRequirement,
      response: paymentRequiredResponse(requiredRequirement)
    };
    return enriched;
  }
  return requirement;
}
var resolvePaymentRequirement = (entrypoint, kind, payments2) => {
  if (!payments2) {
    return { required: false };
  }
  const network = entrypoint.network ?? payments2.network;
  if (!network) {
    return { required: false };
  }
  const price = resolvePrice(entrypoint, payments2, kind);
  if (!price) {
    return { required: false };
  }
  return {
    required: true,
    payTo: payments2.payTo,
    price,
    network,
    facilitatorUrl: payments2.facilitatorUrl
  };
};
var paymentRequiredResponse = (requirement) => {
  const headers = new Headers({
    "Content-Type": "application/json; charset=utf-8",
    "X-Price": requirement.price,
    "X-Network": requirement.network,
    "X-Pay-To": requirement.payTo
  });
  if (requirement.facilitatorUrl) {
    headers.set("X-Facilitator", requirement.facilitatorUrl);
  }
  return new Response(
    JSON.stringify({
      error: {
        code: "payment_required",
        price: requirement.price,
        network: requirement.network,
        payTo: requirement.payTo
      }
    }),
    {
      status: 402,
      headers
    }
  );
};
function createStorageFromConfig(storageConfig, agentId) {
  if (!storageConfig) {
    return createSQLitePaymentStorage();
  }
  switch (storageConfig.type) {
    case "in-memory":
      return createInMemoryPaymentStorage();
    case "postgres":
      if (!storageConfig.postgres?.connectionString) {
        throw new Error(
          "Postgres storage requires connectionString in postgres config"
        );
      }
      return createPostgresPaymentStorage(
        storageConfig.postgres.connectionString,
        agentId
      );
    case "sqlite":
    default:
      return createSQLitePaymentStorage(storageConfig.sqlite?.dbPath);
  }
}
function createPaymentsRuntime(paymentsOption, agentId, customStorageFactory) {
  const config = paymentsOption === false ? void 0 : paymentsOption;
  if (!config) {
    return void 0;
  }
  let isActive = false;
  let paymentTracker;
  let rateLimiter;
  const policyGroups = config.policyGroups;
  try {
    const storage = customStorageFactory ? customStorageFactory(config.storage, agentId) : createStorageFromConfig(config.storage, agentId);
    paymentTracker = createPaymentTracker(storage);
  } catch (error) {
    throw new Error(
      `Failed to initialize payment storage: ${error.message}`
    );
  }
  if (policyGroups && policyGroups.length > 0) {
    const needsRateLimiter = policyGroups.some(
      (group) => group.rateLimits !== void 0
    );
    if (needsRateLimiter) {
      rateLimiter = createRateLimiter();
    }
  }
  return {
    get config() {
      return config;
    },
    get isActive() {
      return isActive;
    },
    get paymentTracker() {
      return paymentTracker;
    },
    get rateLimiter() {
      return rateLimiter;
    },
    get policyGroups() {
      return policyGroups;
    },
    requirements(entrypoint, kind) {
      return evaluatePaymentRequirement(
        entrypoint,
        kind,
        isActive ? config : void 0
      );
    },
    activate(entrypoint) {
      if (isActive || !config) return;
      if (entrypointHasExplicitPrice(entrypoint)) {
        isActive = true;
      }
    },
    resolvePrice(entrypoint, which) {
      return resolvePrice(entrypoint, config, which);
    },
    async getFetchWithPayment(runtime, network) {
      const { createRuntimePaymentContext: createRuntimePaymentContext2 } = await Promise.resolve().then(() => (init_runtime(), runtime_exports));
      const paymentContext = await createRuntimePaymentContext2({
        runtime,
        network
      });
      return paymentContext.fetchWithPayment;
    }
  };
}

// src/index.ts
init_runtime();

// src/utils.ts
function paymentsFromEnv(configOverrides) {
  const baseConfig = {
    payTo: configOverrides?.payTo ?? process.env.PAYMENTS_RECEIVABLE_ADDRESS,
    facilitatorUrl: configOverrides?.facilitatorUrl ?? process.env.FACILITATOR_URL,
    network: configOverrides?.network ?? process.env.NETWORK
  };
  return {
    ...baseConfig,
    ...configOverrides
  };
}
function extractSenderDomain(urlOrOrigin, referer) {
  if (urlOrOrigin) {
    try {
      return new URL(urlOrOrigin).hostname;
    } catch {
    }
  }
  if (referer) {
    try {
      return new URL(referer).hostname;
    } catch {
    }
  }
  return void 0;
}
function extractPayerAddress(paymentResponseHeader) {
  if (!paymentResponseHeader) return void 0;
  try {
    const decoded = JSON.parse(
      Buffer.from(paymentResponseHeader, "base64").toString("utf-8")
    );
    return decoded.payer;
  } catch {
    return void 0;
  }
}
function parsePriceAmount(price) {
  try {
    const priceNum = parseFloat(price);
    if (!Number.isFinite(priceNum) || priceNum < 0) return void 0;
    return BigInt(Math.floor(priceNum * 1e6));
  } catch {
    return void 0;
  }
}
var DEFAULT_MODEL = "gpt-5";
var DEFAULT_PROVIDER = "openai";
var DEFAULT_API_URL = "https://api-beta.daydreams.systems/v1";
var MAX_PAYMENT_BASE_UNITS = "10000000";
var createX402Fetch = ({
  account,
  fetchImpl
}) => {
  if (!account) {
    throw new Error("[agent-kit-payments] createX402Fetch requires an account");
  }
  const accountAddress = typeof account === "object" && account && "address" in account ? account.address : void 0;
  console.info(
    "[agent-kit-payments:x402] creating paid fetch",
    accountAddress ? `for ${accountAddress}` : "(account address unavailable)"
  );
  const paymentFetch = wrapFetchWithPayment(
    fetchImpl ?? fetch,
    account,
    BigInt(MAX_PAYMENT_BASE_UNITS)
  );
  console.info("[agent-kit-payments:x402] wrapFetchWithPayment initialised");
  const describeInput = (input) => {
    if (typeof input === "string") return input;
    if (input instanceof URL) return input.toString();
    if (typeof input?.url === "string") {
      return input.url;
    }
    return "[object Request]";
  };
  const wrappedFetch = Object.assign(
    async (input, init) => {
      const requestUrl = describeInput(input);
      const requestMethod = init?.method ?? (input instanceof Request ? input.method : void 0) ?? "POST";
      console.info(
        "[agent-kit-payments:x402] fetch request",
        requestUrl,
        requestMethod
      );
      try {
        const response = await paymentFetch(input, init ?? {});
        const paymentHeader = response.headers.get("X-PAYMENT-RESPONSE");
        console.info(
          "[agent-kit-payments:x402] fetch response",
          requestUrl,
          response.status,
          paymentHeader ? "(paid)" : "(no x402 header)"
        );
        return response;
      } catch (error) {
        console.warn(
          "[agent-kit-payments:x402] fetch failed",
          requestUrl,
          error?.message ?? error
        );
        throw error;
      }
    },
    {
      preconnect: paymentFetch.preconnect ?? (async () => {
      })
    }
  );
  return wrappedFetch;
};
var accountFromPrivateKey = (privateKey) => {
  if (!privateKey || privateKey.trim().length === 0) {
    throw new Error(
      "[agent-kit-payments] accountFromPrivateKey requires a non-empty private key"
    );
  }
  return privateKeyToAccount(privateKey);
};
var createX402LLM = (options = {}) => {
  if (options.account) {
    console.info(
      "[agent-kit-payments:x402] initialising LLM with provided account"
    );
  } else if (options.privateKey) {
    console.info(
      "[agent-kit-payments:x402] deriving account from supplied private key"
    );
  } else {
    console.info(
      "[agent-kit-payments:x402] no explicit account/private key supplied; falling back to env or downstream defaults"
    );
  }
  const account = options.account ?? (options.privateKey ? accountFromPrivateKey(options.privateKey) : void 0);
  if (!account) {
    throw new Error(
      "[agent-kit-payments] createX402LLM requires either an account or a private key"
    );
  }
  const paymentFetch = options.fetch ?? createX402Fetch({ account, fetchImpl: options.fetchImpl });
  console.info("[agent-kit-payments:x402] payment-enabled fetch ready for LLM");
  const aiOverrides = options.ai ?? {};
  const {
    config: configOverridesRaw,
    options: optionOverridesRaw,
    apiKey: apiKeyOverrideRaw,
    apiURL: apiUrlOverrideRaw,
    name: nameOverrideRaw,
    ...restAiProps
  } = aiOverrides;
  const configOverrides = configOverridesRaw && typeof configOverridesRaw === "object" ? configOverridesRaw : void 0;
  const optionOverrides = optionOverridesRaw && typeof optionOverridesRaw === "object" ? optionOverridesRaw : void 0;
  const explicitApiKey = typeof apiKeyOverrideRaw === "string" && apiKeyOverrideRaw.trim().length > 0 ? apiKeyOverrideRaw : void 0;
  const nameOverride = typeof nameOverrideRaw === "string" && nameOverrideRaw.trim().length > 0 ? nameOverrideRaw : void 0;
  const apiUrlOverride = typeof apiUrlOverrideRaw === "string" && apiUrlOverrideRaw.trim().length > 0 ? apiUrlOverrideRaw : void 0;
  const apiKey = explicitApiKey ?? process.env.OPENAI_API_KEY;
  if (!apiKey) {
    throw new Error(
      "[agent-kit-payments] createX402LLM requires an OpenAI API key (set options.ai.apiKey or OPENAI_API_KEY)"
    );
  }
  const baseConfig = {
    stream: false
  };
  const finalConfig = {
    ...baseConfig,
    ...configOverrides ?? {}
  };
  const finalOptions = {
    ...optionOverrides ?? {},
    fetch: paymentFetch
  };
  const aiArgs = {
    ...restAiProps,
    name: nameOverride ?? DEFAULT_PROVIDER,
    apiKey,
    apiURL: apiUrlOverride ?? DEFAULT_API_URL,
    config: finalConfig,
    options: finalOptions
  };
  console.info(
    "[agent-kit-payments:x402] creating Ax client",
    `provider=${aiArgs.name}`,
    `model=${finalConfig.model}`
  );
  return ai(aiArgs);
};
var x402LLM = ({
  privateKey = process.env.PRIVATE_KEY,
  model = DEFAULT_MODEL,
  apiURL = DEFAULT_API_URL
}) => createX402LLM({
  privateKey,
  ai: { apiURL }
});

// src/index.ts
init_crypto();
var OutgoingLimitSchema = z.object({
  maxPaymentUsd: z.number().positive().optional(),
  maxTotalUsd: z.number().positive().optional(),
  windowMs: z.number().int().positive().optional()
});
var OutgoingLimitsConfigSchema = z.object({
  global: OutgoingLimitSchema.optional(),
  perTarget: z.record(z.string(), OutgoingLimitSchema).optional(),
  perEndpoint: z.record(z.string(), OutgoingLimitSchema).optional()
});
var IncomingLimitSchema = z.object({
  maxPaymentUsd: z.number().positive().optional(),
  maxTotalUsd: z.number().positive().optional(),
  windowMs: z.number().int().positive().optional()
});
var IncomingLimitsConfigSchema = z.object({
  global: IncomingLimitSchema.optional(),
  perSender: z.record(z.string(), IncomingLimitSchema).optional(),
  perEndpoint: z.record(z.string(), IncomingLimitSchema).optional()
});
var RateLimitConfigSchema = z.object({
  maxPayments: z.number().int().positive(),
  windowMs: z.number().int().positive()
});
var PaymentPolicyGroupSchema = z.object({
  name: z.string().min(1),
  outgoingLimits: OutgoingLimitsConfigSchema.optional(),
  incomingLimits: IncomingLimitsConfigSchema.optional(),
  allowedRecipients: z.array(z.string()).optional(),
  blockedRecipients: z.array(z.string()).optional(),
  allowedSenders: z.array(z.string()).optional(),
  blockedSenders: z.array(z.string()).optional(),
  rateLimits: RateLimitConfigSchema.optional()
});
var PaymentPolicyGroupsSchema = z.array(PaymentPolicyGroupSchema);

// src/policy-config.ts
function loadPoliciesFromConfig(configPath) {
  const filePath = configPath ?? join(process.cwd(), "payment-policies.json");
  try {
    const fileContent = readFileSync(filePath, "utf-8");
    const json = JSON.parse(fileContent);
    const result = PaymentPolicyGroupsSchema.safeParse(json);
    if (!result.success) {
      throw new Error(
        `Invalid payment policies config: ${result.error.issues.map((e) => `${e.path.join(".")}: ${e.message}`).join(", ")}`
      );
    }
    return result.data;
  } catch (error) {
    if (error.code === "ENOENT") {
      return void 0;
    }
    if (error instanceof SyntaxError) {
      throw new Error(
        `Failed to parse payment-policies.json: ${error.message}`
      );
    }
    if (error instanceof Error) {
      throw error;
    }
    throw new Error("Failed to load payment policies config");
  }
}

// src/env.ts
function policiesFromConfig(configPath) {
  return loadPoliciesFromConfig(configPath);
}

// src/extension.ts
function payments(options) {
  let paymentsRuntime;
  return {
    name: "payments",
    build(ctx) {
      let config = options?.config;
      if (config !== false && config !== void 0 && options?.policies) {
        try {
          const policyGroups = policiesFromConfig(options.policies);
          if (policyGroups) {
            config = { ...config, policyGroups };
          }
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          throw new Error(`Failed to load policies from config: ${message}`, {
            cause: error
          });
        }
      }
      paymentsRuntime = createPaymentsRuntime(
        config,
        options?.agentId,
        options?.storageFactory
      );
      return { payments: paymentsRuntime };
    },
    onEntrypointAdded(entrypoint, runtime) {
      if (paymentsRuntime && !paymentsRuntime.isActive && paymentsRuntime.config) {
        if (entrypointHasExplicitPrice(entrypoint)) {
          paymentsRuntime.activate(entrypoint);
        }
      }
    },
    onManifestBuild(card, runtime) {
      if (paymentsRuntime?.config) {
        return createAgentCardWithPayments(
          card,
          paymentsRuntime.config,
          runtime.entrypoints.snapshot()
        );
      }
      return card;
    }
  };
}

// src/index.ts
init_policy();
init_policy_wrapper();

export { ZERO_ADDRESS, accountFromPrivateKey, createAgentCardWithPayments, createInMemoryPaymentStorage, createPaymentTracker, createPaymentsRuntime, createPostgresPaymentStorage, createRateLimiter, createRuntimePaymentContext, createSQLitePaymentStorage, createX402Fetch, createX402LLM, entrypointHasExplicitPrice, evaluateIncomingLimits, evaluateIncomingPolicyGroups, evaluateOutgoingLimits, evaluatePaymentRequirement, evaluatePolicyGroups, evaluateRateLimit, evaluateRecipient, evaluateSender, extractPayerAddress, extractSenderDomain, findMostSpecificIncomingLimit, findMostSpecificOutgoingLimit, normalizeAddress, parsePriceAmount, paymentRequiredResponse, payments, paymentsFromEnv, resolveActivePayments, resolvePaymentRequirement, resolvePrice, sanitizeAddress, validatePaymentsConfig, wrapBaseFetchWithPolicy, x402LLM };
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map