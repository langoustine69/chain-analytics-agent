{"version":3,"sources":["../src/crypto.ts","../src/policy.ts","../src/policy-wrapper.ts","../src/runtime.ts","../src/pricing.ts","../src/manifest.ts","../src/validation.ts","../src/sqlite-payment-storage.ts","../src/payment-tracker.ts","../src/rate-limiter.ts","../src/in-memory-payment-storage.ts","../src/postgres-payment-storage.ts","../src/payments.ts","../src/index.ts","../src/utils.ts","../src/x402.ts","../src/policy-schema.ts","../src/policy-config.ts","../src/env.ts","../src/extension.ts"],"names":["formatUsdcAmount","extractDomain","signer","payments","createRuntimePaymentContext","wrapFetchWithPayment"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Address normalization and validation utilities.\n */\n\nexport type Hex = `0x${string}`;\n\nexport const ZERO_ADDRESS: Hex = '0x0000000000000000000000000000000000000000';\n\n/**\n * Normalize an Ethereum address to lowercase hex format\n * Throws if the address is invalid\n */\nexport function normalizeAddress(value: string | null | undefined): Hex {\n  if (!value) {\n    throw new Error('invalid hex address');\n  }\n  const trimmed = value.trim();\n  if (!/^0x[0-9a-fA-F]{40}$/.test(trimmed)) {\n    throw new Error(`invalid hex address: ${value}`);\n  }\n  return trimmed.toLowerCase() as Hex;\n}\n\n/**\n * Sanitize an address - returns ZERO_ADDRESS if invalid instead of throwing\n */\nexport function sanitizeAddress(value: string | null | undefined): Hex {\n  if (!value) return ZERO_ADDRESS;\n  const trimmed = value.trim();\n  if (!/^0x[0-9a-fA-F]{40}$/.test(trimmed)) {\n    return ZERO_ADDRESS;\n  }\n  return trimmed.toLowerCase() as Hex;\n}\n\n","import type {\n  PaymentPolicyGroup,\n  OutgoingLimit,\n  OutgoingLimitsConfig,\n  IncomingLimit,\n  IncomingLimitsConfig,\n} from '@lucid-agents/types/payments';\nimport type { PaymentTracker } from './payment-tracker';\nimport type { RateLimiter } from './rate-limiter';\n\n/**\n * Result of policy evaluation.\n */\nexport type PolicyEvaluationResult = {\n  allowed: boolean;\n  reason?: string;\n  groupName?: string;\n};\n\n/**\n * Extracts the domain from a URL string.\n * @param url - Full URL (e.g., \"https://agent.example.com/entrypoints/process/invoke\")\n * @returns Domain (e.g., \"agent.example.com\") or undefined if URL is invalid\n */\nfunction extractDomain(url: string): string | undefined {\n  try {\n    const parsed = new URL(url);\n    return parsed.hostname;\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * Normalizes a URL for matching (removes trailing slashes, converts to lowercase).\n * @param url - URL to normalize\n * @returns Normalized URL\n */\nfunction normalizeUrl(url: string): string {\n  return url.trim().toLowerCase().replace(/\\/+$/, '');\n}\n\n/**\n * Formats a BigInt amount (in base units with 6 decimals) to a human-friendly USDC string.\n * @param amount - Amount in base units (USDC has 6 decimals)\n * @returns Formatted string (e.g., \"1.5\" for 1.5 USDC, \"1\" for 1.0 USDC)\n */\nfunction formatUsdcAmount(amount: bigint): string {\n  const usdc = Number(amount) / 1_000_000;\n  return usdc.toFixed(6).replace(/\\.?0+$/, '');\n}\n\n/**\n * Extracts domain from a URL string or returns the input if it's already a domain.\n * Handles both full URLs (https://example.com) and plain domains (example.com).\n * @param urlOrDomain - URL string or domain\n * @returns Domain string (lowercase, normalized)\n */\nfunction extractDomainFromUrlOrDomain(urlOrDomain: string): string {\n  const domain = extractDomain(urlOrDomain);\n  if (domain) {\n    return domain.toLowerCase();\n  }\n  return normalizeUrl(urlOrDomain);\n}\n\n/**\n * Checks if two domains match (exact match or subdomain).\n * @param domain1 - First domain (already normalized)\n * @param domain2 - Second domain (already normalized)\n * @returns True if domains match\n */\nfunction domainsMatch(domain1: string, domain2: string): boolean {\n  const normalized1 = normalizeUrl(domain1);\n  const normalized2 = normalizeUrl(domain2);\n\n  if (normalized1 === normalized2) {\n    return true;\n  }\n\n  if (normalized1.endsWith(`.${normalized2}`)) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Evaluates sender whitelist/blacklist for a policy group (incoming payments).\n * Similar to evaluateRecipient but for incoming payments.\n * @param group - Policy group to evaluate\n * @param senderAddress - Sender address (EVM or Solana)\n * @param senderDomain - Sender domain (from URL)\n * @returns Evaluation result\n */\nexport function evaluateSender(\n  group: PaymentPolicyGroup,\n  senderAddress?: string,\n  senderDomain?: string\n): PolicyEvaluationResult {\n  if (group.blockedSenders && group.blockedSenders.length > 0) {\n    for (const blocked of group.blockedSenders) {\n      const blockedDomain = extractDomainFromUrlOrDomain(blocked);\n      const normalizedBlocked = normalizeUrl(blocked);\n\n      if (senderAddress && normalizeUrl(senderAddress) === normalizedBlocked) {\n        return {\n          allowed: false,\n          reason: `Sender address \"${senderAddress}\" is blocked by policy group \"${group.name}\"`,\n          groupName: group.name,\n        };\n      }\n\n      if (senderDomain) {\n        const normalizedDomain = normalizeUrl(senderDomain);\n        if (domainsMatch(normalizedDomain, blockedDomain)) {\n          return {\n            allowed: false,\n            reason: `Sender domain \"${senderDomain}\" is blocked by policy group \"${group.name}\"`,\n            groupName: group.name,\n          };\n        }\n      }\n    }\n  }\n\n  if (group.allowedSenders && group.allowedSenders.length > 0) {\n    let isAllowed = false;\n\n    for (const allowed of group.allowedSenders) {\n      const allowedDomain = extractDomainFromUrlOrDomain(allowed);\n      const normalizedAllowed = normalizeUrl(allowed);\n\n      if (senderAddress && normalizeUrl(senderAddress) === normalizedAllowed) {\n        isAllowed = true;\n        break;\n      }\n\n      if (senderDomain) {\n        const normalizedDomain = normalizeUrl(senderDomain);\n        if (domainsMatch(normalizedDomain, allowedDomain)) {\n          isAllowed = true;\n          break;\n        }\n      }\n    }\n\n    if (!isAllowed) {\n      return {\n        allowed: false,\n        reason: `Sender \"${senderAddress || senderDomain || 'unknown'}\" is not in the whitelist for policy group \"${group.name}\"`,\n        groupName: group.name,\n      };\n    }\n  }\n\n  return { allowed: true };\n}\n\n/**\n * Evaluates recipient whitelist/blacklist for a policy group (outgoing payments).\n * @param group - Policy group to evaluate\n * @param recipientAddress - Recipient address (EVM or Solana)\n * @param recipientDomain - Recipient domain (from URL)\n * @returns Evaluation result\n */\nexport function evaluateRecipient(\n  group: PaymentPolicyGroup,\n  recipientAddress?: string,\n  recipientDomain?: string\n): PolicyEvaluationResult {\n  if (group.blockedRecipients && group.blockedRecipients.length > 0) {\n    for (const blocked of group.blockedRecipients) {\n      const blockedDomain = extractDomainFromUrlOrDomain(blocked);\n      const normalizedBlocked = normalizeUrl(blocked);\n\n      if (\n        recipientAddress &&\n        normalizeUrl(recipientAddress) === normalizedBlocked\n      ) {\n        return {\n          allowed: false,\n          reason: `Recipient address \"${recipientAddress}\" is blocked by policy group \"${group.name}\"`,\n          groupName: group.name,\n        };\n      }\n\n      if (recipientDomain) {\n        const normalizedDomain = normalizeUrl(recipientDomain);\n        if (domainsMatch(normalizedDomain, blockedDomain)) {\n          return {\n            allowed: false,\n            reason: `Recipient domain \"${recipientDomain}\" is blocked by policy group \"${group.name}\"`,\n            groupName: group.name,\n          };\n        }\n      }\n    }\n  }\n\n  if (group.allowedRecipients && group.allowedRecipients.length > 0) {\n    let isAllowed = false;\n\n    for (const allowed of group.allowedRecipients) {\n      const allowedDomain = extractDomainFromUrlOrDomain(allowed);\n      const normalizedAllowed = normalizeUrl(allowed);\n\n      if (\n        recipientAddress &&\n        normalizeUrl(recipientAddress) === normalizedAllowed\n      ) {\n        isAllowed = true;\n        break;\n      }\n\n      if (recipientDomain) {\n        const normalizedDomain = normalizeUrl(recipientDomain);\n        if (domainsMatch(normalizedDomain, allowedDomain)) {\n          isAllowed = true;\n          break;\n        }\n      }\n    }\n\n    if (!isAllowed) {\n      return {\n        allowed: false,\n        reason: `Recipient \"${recipientAddress || recipientDomain || 'unknown'}\" is not in the whitelist for policy group \"${group.name}\"`,\n        groupName: group.name,\n      };\n    }\n  }\n\n  return { allowed: true };\n}\n\n/**\n * Evaluates rate limit for a policy group.\n * @param group - Policy group to evaluate\n * @param rateLimiter - Rate limiter instance\n * @returns Evaluation result\n */\nexport function evaluateRateLimit(\n  group: PaymentPolicyGroup,\n  rateLimiter: RateLimiter\n): PolicyEvaluationResult {\n  if (!group.rateLimits) {\n    return { allowed: true };\n  }\n\n  const { maxPayments, windowMs } = group.rateLimits;\n  return rateLimiter.checkLimit(group.name, maxPayments, windowMs);\n}\n\n/**\n * Finds the most specific outgoing limit for a given scope.\n * Hierarchy: endpoint > target > global\n * @param limits - Outgoing limits configuration\n * @param targetUrl - Target agent URL (optional)\n * @param endpointUrl - Full endpoint URL (optional)\n * @returns Most specific outgoing limit with resolved scope, or undefined\n */\nexport function findMostSpecificOutgoingLimit(\n  limits: OutgoingLimitsConfig,\n  targetUrl?: string,\n  endpointUrl?: string\n): { limit: OutgoingLimit; scope: string } | undefined {\n  if (endpointUrl && limits.perEndpoint) {\n    const normalizedEndpoint = normalizeUrl(endpointUrl);\n    for (const [key, limit] of Object.entries(limits.perEndpoint)) {\n      if (normalizeUrl(key) === normalizedEndpoint) {\n        return { limit, scope: endpointUrl };\n      }\n    }\n  }\n\n  if (targetUrl && limits.perTarget) {\n    const targetDomain = extractDomain(targetUrl);\n    if (targetDomain) {\n      const normalizedTarget = normalizeUrl(targetUrl);\n      const normalizedDomain = normalizeUrl(targetDomain);\n\n      for (const [key, limit] of Object.entries(limits.perTarget)) {\n        const normalizedKey = normalizeUrl(key);\n        const keyDomain = extractDomain(key);\n        const normalizedKeyDomain = keyDomain\n          ? normalizeUrl(keyDomain)\n          : undefined;\n\n        if (\n          normalizedKey === normalizedTarget ||\n          normalizedKey === normalizedDomain ||\n          (normalizedKeyDomain && normalizedKeyDomain === normalizedDomain) ||\n          (keyDomain && normalizeUrl(keyDomain) === normalizedDomain)\n        ) {\n          return { limit, scope: normalizedKey };\n        }\n      }\n    }\n  }\n\n  if (limits.global) {\n    return { limit: limits.global, scope: 'global' };\n  }\n\n  return undefined;\n}\n\n/**\n * Finds the most specific incoming limit for a given scope.\n * Hierarchy: endpoint > sender > global\n * @param limits - Incoming limits configuration\n * @param senderAddress - Sender address (optional)\n * @param senderDomain - Sender domain (optional)\n * @param endpointUrl - Full endpoint URL (optional)\n * @returns Most specific incoming limit with resolved scope, or undefined\n */\nexport function findMostSpecificIncomingLimit(\n  limits: IncomingLimitsConfig,\n  senderAddress?: string,\n  senderDomain?: string,\n  endpointUrl?: string\n): { limit: IncomingLimit; scope: string } | undefined {\n  if (endpointUrl && limits.perEndpoint) {\n    const normalizedEndpoint = normalizeUrl(endpointUrl);\n    for (const [key, limit] of Object.entries(limits.perEndpoint)) {\n      if (normalizeUrl(key) === normalizedEndpoint) {\n        return { limit, scope: endpointUrl };\n      }\n    }\n  }\n\n  if (senderAddress && limits.perSender) {\n    const normalizedSender = normalizeUrl(senderAddress);\n    for (const [key, limit] of Object.entries(limits.perSender)) {\n      if (normalizeUrl(key) === normalizedSender) {\n        return { limit, scope: key };\n      }\n    }\n  }\n\n  if (senderDomain && limits.perSender) {\n    const normalizedDomain = normalizeUrl(senderDomain);\n    for (const [key, limit] of Object.entries(limits.perSender)) {\n      const keyDomain = extractDomain(key);\n      if (keyDomain && normalizeUrl(keyDomain) === normalizedDomain) {\n        return { limit, scope: key };\n      }\n    }\n  }\n\n  if (limits.global) {\n    return { limit: limits.global, scope: 'global' };\n  }\n\n  return undefined;\n}\n\n/**\n * Evaluates outgoing payment limits for a policy group.\n * Checks both per-request limits (stateless) and total outgoing limits (stateful).\n * @param group - Policy group to evaluate\n * @param paymentTracker - Payment tracker instance\n * @param targetUrl - Target agent URL (optional)\n * @param endpointUrl - Full endpoint URL (optional)\n * @param requestedAmount - Requested payment amount in base units\n * @returns Evaluation result\n */\nexport async function evaluateOutgoingLimits(\n  group: PaymentPolicyGroup,\n  paymentTracker: PaymentTracker,\n  targetUrl?: string,\n  endpointUrl?: string,\n  requestedAmount?: bigint\n): Promise<PolicyEvaluationResult> {\n  if (!group.outgoingLimits || requestedAmount === undefined) {\n    return { allowed: true };\n  }\n\n  const limitInfo = findMostSpecificOutgoingLimit(\n    group.outgoingLimits,\n    targetUrl,\n    endpointUrl\n  );\n\n  if (!limitInfo) {\n    return { allowed: true };\n  }\n\n  const { limit, scope } = limitInfo;\n\n  if (limit.maxPaymentUsd !== undefined) {\n    const maxPaymentBaseUnits = BigInt(\n      Math.floor(limit.maxPaymentUsd * 1_000_000)\n    );\n    if (requestedAmount > maxPaymentBaseUnits) {\n      return {\n        allowed: false,\n        reason: `Per-request outgoing limit exceeded for policy group \"${group.name}\" at scope \"${scope}\". Requested: ${formatUsdcAmount(requestedAmount)} USDC, Limit: ${limit.maxPaymentUsd} USDC`,\n        groupName: group.name,\n      };\n    }\n  }\n\n  if (limit.maxTotalUsd !== undefined) {\n    const checkResult = await paymentTracker.checkOutgoingLimit(\n      group.name,\n      scope,\n      limit.maxTotalUsd,\n      limit.windowMs,\n      requestedAmount\n    );\n\n    if (!checkResult.allowed) {\n      return {\n        allowed: false,\n        reason: checkResult.reason,\n        groupName: group.name,\n      };\n    }\n  }\n\n  return { allowed: true };\n}\n\n/**\n * Evaluates incoming payment limits for a policy group.\n * Checks both per-request limits (stateless) and total incoming limits (stateful).\n * @param group - Policy group to evaluate\n * @param paymentTracker - Payment tracker instance\n * @param senderAddress - Sender address (optional)\n * @param senderDomain - Sender domain (optional)\n * @param endpointUrl - Full endpoint URL (optional)\n * @param requestedAmount - Requested payment amount in base units\n * @returns Evaluation result\n */\nexport async function evaluateIncomingLimits(\n  group: PaymentPolicyGroup,\n  paymentTracker: PaymentTracker,\n  senderAddress?: string,\n  senderDomain?: string,\n  endpointUrl?: string,\n  requestedAmount?: bigint\n): Promise<PolicyEvaluationResult> {\n  if (!group.incomingLimits || requestedAmount === undefined) {\n    return { allowed: true };\n  }\n\n  const limitInfo = findMostSpecificIncomingLimit(\n    group.incomingLimits,\n    senderAddress,\n    senderDomain,\n    endpointUrl\n  );\n\n  if (!limitInfo) {\n    return { allowed: true };\n  }\n\n  const { limit, scope } = limitInfo;\n\n  if (limit.maxPaymentUsd !== undefined) {\n    const maxPaymentBaseUnits = BigInt(\n      Math.floor(limit.maxPaymentUsd * 1_000_000)\n    );\n    if (requestedAmount > maxPaymentBaseUnits) {\n      return {\n        allowed: false,\n        reason: `Per-request incoming limit exceeded for policy group \"${group.name}\" at scope \"${scope}\". Requested: ${formatUsdcAmount(requestedAmount)} USDC, Limit: ${limit.maxPaymentUsd} USDC`,\n        groupName: group.name,\n      };\n    }\n  }\n\n  if (limit.maxTotalUsd !== undefined) {\n    const checkResult = await paymentTracker.checkIncomingLimit(\n      group.name,\n      scope,\n      limit.maxTotalUsd,\n      limit.windowMs,\n      requestedAmount\n    );\n\n    if (!checkResult.allowed) {\n      return {\n        allowed: false,\n        reason: checkResult.reason,\n        groupName: group.name,\n      };\n    }\n  }\n\n  return { allowed: true };\n}\n\n/**\n * Evaluates all policy groups for outgoing payments.\n * All groups must pass - first violation blocks the payment.\n * @param groups - Array of policy groups to evaluate\n * @param paymentTracker - Payment tracker instance\n * @param rateLimiter - Rate limiter instance\n * @param targetUrl - Target agent URL (optional)\n * @param endpointUrl - Full endpoint URL (optional)\n * @param requestedAmount - Requested payment amount in base units\n * @param recipientAddress - Recipient address (optional)\n * @param recipientDomain - Recipient domain (optional)\n * @returns Evaluation result (first violation blocks)\n */\nexport async function evaluatePolicyGroups(\n  groups: PaymentPolicyGroup[],\n  paymentTracker: PaymentTracker,\n  rateLimiter: RateLimiter,\n  targetUrl?: string,\n  endpointUrl?: string,\n  requestedAmount?: bigint,\n  recipientAddress?: string,\n  recipientDomain?: string\n): Promise<PolicyEvaluationResult> {\n  if (targetUrl && !recipientDomain) {\n    recipientDomain = extractDomain(targetUrl);\n  }\n\n  for (const group of groups) {\n    const recipientResult = evaluateRecipient(\n      group,\n      recipientAddress,\n      recipientDomain\n    );\n    if (!recipientResult.allowed) {\n      return recipientResult;\n    }\n\n    const outgoingResult = await evaluateOutgoingLimits(\n      group,\n      paymentTracker,\n      targetUrl,\n      endpointUrl,\n      requestedAmount\n    );\n    if (!outgoingResult.allowed) {\n      return outgoingResult;\n    }\n\n    const rateResult = evaluateRateLimit(group, rateLimiter);\n    if (!rateResult.allowed) {\n      return rateResult;\n    }\n  }\n\n  return { allowed: true };\n}\n\n/**\n * Evaluates all policy groups for incoming payments.\n * All groups must pass - first violation blocks the service (payment already received).\n * @param groups - Array of policy groups to evaluate\n * @param paymentTracker - Payment tracker instance\n * @param senderAddress - Sender address (optional)\n * @param senderDomain - Sender domain (optional)\n * @param endpointUrl - Full endpoint URL (optional)\n * @param requestedAmount - Requested payment amount in base units\n * @returns Evaluation result (first violation blocks)\n */\nexport async function evaluateIncomingPolicyGroups(\n  groups: PaymentPolicyGroup[],\n  paymentTracker: PaymentTracker,\n  senderAddress?: string,\n  senderDomain?: string,\n  endpointUrl?: string,\n  requestedAmount?: bigint\n): Promise<PolicyEvaluationResult> {\n  for (const group of groups) {\n    const senderResult = evaluateSender(group, senderAddress, senderDomain);\n    if (!senderResult.allowed) {\n      return senderResult;\n    }\n\n    const incomingResult = await evaluateIncomingLimits(\n      group,\n      paymentTracker,\n      senderAddress,\n      senderDomain,\n      endpointUrl,\n      requestedAmount\n    );\n    if (!incomingResult.allowed) {\n      return incomingResult;\n    }\n  }\n\n  return { allowed: true };\n}\n","import type { PaymentPolicyGroup } from '@lucid-agents/types/payments';\nimport type { PaymentTracker } from './payment-tracker';\nimport type { RateLimiter } from './rate-limiter';\nimport { evaluatePolicyGroups, findMostSpecificOutgoingLimit } from './policy';\n\ntype FetchLike = (\n  input: RequestInfo | URL,\n  init?: RequestInit\n) => Promise<Response>;\n\n/**\n * Extracts the URL string from fetch input.\n * @param input - Request info (string, URL, or Request object)\n * @returns URL string representation\n */\nfunction getUrlString(input: RequestInfo | URL): string {\n  if (typeof input === 'string') return input;\n  if (input instanceof URL) return input.toString();\n  if (input instanceof Request) return input.url;\n  return String(input);\n}\n\n/**\n * Extracts the domain from a URL.\n * @param url - URL string to extract domain from\n * @returns Hostname if URL is valid, undefined otherwise\n */\nfunction extractDomain(url: string): string | undefined {\n  try {\n    const parsed = new URL(url);\n    return parsed.hostname;\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * Parses payment amount from a price string (assumes USDC with 6 decimals).\n * @param price - Price string (e.g., \"1.5\" for $1.50)\n * @returns Amount in base units (with 6 decimals), or undefined if invalid\n */\nfunction parsePriceToBaseUnits(\n  price: string | null | undefined\n): bigint | undefined {\n  if (!price) return undefined;\n\n  try {\n    const priceNum = parseFloat(price);\n    if (!Number.isFinite(priceNum) || priceNum < 0) return undefined;\n    return BigInt(Math.floor(priceNum * 1_000_000));\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * Extracts payment amount from response headers.\n * @param response - HTTP response object\n * @returns Payment amount in base units from X-Price header, or undefined\n */\nfunction extractPaymentAmount(response: Response): bigint | undefined {\n  const priceHeader = response.headers.get('X-Price');\n  return parsePriceToBaseUnits(priceHeader);\n}\n\n/**\n * Extracts recipient address from payment request headers or response.\n * @param request - HTTP request object\n * @param response - HTTP response object\n * @returns Recipient address from X-Pay-To header, or undefined\n */\nfunction extractRecipientAddress(\n  request: Request,\n  response: Response\n): string | undefined {\n  const payToHeader = response.headers.get('X-Pay-To');\n  if (payToHeader) return payToHeader;\n  return undefined;\n}\n\ntype PaymentInfo = {\n  amount: bigint;\n  recipientAddress?: string;\n  recipientDomain?: string;\n};\n\n/**\n * Creates a policy wrapper around the BASE fetch (before x402 wrapper).\n * This wrapper is applied BEFORE the x402 wrapper so we can intercept\n * the 402 response and check policies before payment happens.\n *\n * Flow:\n * 1. Wraps the base fetch function\n * 2. Intercepts 402 responses to extract payment information\n * 3. Evaluates policies against spending limits and rate limits\n * 4. Returns 403 if policy violation, otherwise allows payment\n * 5. Records spending/rate limit data after successful payment\n *\n * @param baseFetch - The base fetch function to wrap\n * @param policyGroups - Array of payment policy groups to evaluate\n * @param paymentTracker - Tracker for enforcing payment limits\n * @param rateLimiter - Limiter for enforcing rate limits\n * @returns Wrapped fetch function that enforces payment policies\n */\nexport function wrapBaseFetchWithPolicy(\n  baseFetch: FetchLike,\n  policyGroups: PaymentPolicyGroup[],\n  paymentTracker: PaymentTracker,\n  rateLimiter: RateLimiter\n): FetchLike {\n  const paymentInfoCache = new Map<string, PaymentInfo>();\n\n  return async (input: RequestInfo | URL, init?: RequestInit) => {\n    const urlString = getUrlString(input);\n    const targetUrl = urlString;\n    const endpointUrl = urlString;\n    const targetDomain = extractDomain(urlString);\n    const requestKey = `${urlString}:${init?.method || 'GET'}`;\n\n    const response = await baseFetch(input, init);\n\n    if (response.status === 402) {\n      const paymentAmount = extractPaymentAmount(response);\n      const recipientAddress = extractRecipientAddress(\n        input instanceof Request ? input : new Request(input, init),\n        response\n      );\n\n      if (paymentAmount !== undefined) {\n        const evaluation = await evaluatePolicyGroups(\n          policyGroups,\n          paymentTracker,\n          rateLimiter,\n          urlString,\n          urlString,\n          paymentAmount,\n          recipientAddress || undefined,\n          targetDomain\n        );\n\n        if (!evaluation.allowed) {\n          return new Response(\n            JSON.stringify({\n              error: {\n                code: 'policy_violation',\n                message: evaluation.reason || 'Payment blocked by policy',\n                groupName: evaluation.groupName,\n              },\n            }),\n            {\n              status: 403,\n              headers: {\n                'Content-Type': 'application/json',\n              },\n            }\n          );\n        }\n\n        paymentInfoCache.set(requestKey, {\n          amount: paymentAmount,\n          recipientAddress: recipientAddress || undefined,\n          recipientDomain: targetDomain,\n        });\n      }\n    }\n\n    if (response.ok && response.status >= 200 && response.status < 300) {\n      const paymentResponseHeader = response.headers.get('X-PAYMENT-RESPONSE');\n      if (paymentResponseHeader) {\n        const paymentInfo = paymentInfoCache.get(requestKey);\n        if (paymentInfo) {\n          for (const group of policyGroups) {\n            if (group.outgoingLimits) {\n              const limitInfo = findMostSpecificOutgoingLimit(\n                group.outgoingLimits,\n                targetUrl,\n                endpointUrl\n              );\n              const scope = limitInfo?.scope ?? 'global';\n\n              await paymentTracker.recordOutgoing(\n                group.name,\n                scope,\n                paymentInfo.amount\n              );\n            }\n\n            if (group.rateLimits) {\n              rateLimiter.recordPayment(group.name);\n            }\n          }\n\n          paymentInfoCache.delete(requestKey);\n        }\n      }\n    }\n\n    return response;\n  };\n}\n","import type { AgentRuntime } from '@lucid-agents/types/core';\nimport type { WalletConnector } from '@lucid-agents/types/wallets';\nimport type { Signer } from 'x402/types';\nimport { createSigner, type Hex, wrapFetchWithPayment } from 'x402-fetch';\nimport { sanitizeAddress, ZERO_ADDRESS } from './crypto';\nimport { wrapBaseFetchWithPolicy } from './policy-wrapper';\nimport type { PaymentTracker } from './payment-tracker';\nimport type { RateLimiter } from './rate-limiter';\n\ntype FetchLike = (\n  input: RequestInfo | URL,\n  init?: RequestInit\n) => Promise<Response>;\n\ntype TypedDataPayload = {\n  domain?: Record<string, unknown>;\n  types?: Record<string, Array<{ name: string; type: string }>>;\n  message?: Record<string, unknown>;\n  primaryType: string;\n};\n\ntype RuntimeSigner = {\n  chain: { id: number };\n  account: { address: `0x${string}` | null };\n  transport: { type: string };\n  signTypedData(payload: TypedDataPayload): Promise<`0x${string}`>;\n  signMessage(message: unknown): Promise<`0x${string}`>;\n};\n\nexport type RuntimePaymentLogger = {\n  warn?: (message: string, ...args: unknown[]) => void;\n};\n\nexport type RuntimePaymentOptions = {\n  /**\n   * Existing AgentRuntime instance used to fulfil wallet requests.\n   * Required unless `privateKey` is provided.\n   */\n  runtime?: AgentRuntime;\n  /**\n   * Optional override for the network used to infer the payment chain.\n   */\n  network?: string;\n  /**\n   * Optional explicit chain id. When omitted we attempt to infer it from `network`.\n   */\n  chainId?: number;\n  /**\n   * Maximum payment in base units (USDC has 6 decimals). Falls back to kit config.\n   */\n  maxPaymentBaseUnits?: bigint;\n  /**\n   * Optional direct private key to construct a local signer instead of using runtime wallet APIs.\n   */\n  privateKey?: Hex | string;\n  /**\n   * Fetch implementation to wrap. Defaults to `globalThis.fetch`.\n   */\n  fetch?: FetchLike;\n  /**\n   * Logger used for non-fatal warnings.\n   */\n  logger?: RuntimePaymentLogger;\n};\n\nexport type RuntimePaymentContext = {\n  fetchWithPayment: FetchLike | null;\n  signer: Signer | null;\n  walletAddress: `0x${string}` | null;\n  chainId: number | null;\n};\n\nfunction logWarning(\n  logger: RuntimePaymentLogger | undefined,\n  message: string,\n  ...args: unknown[]\n) {\n  if (logger?.warn) {\n    logger.warn(message, ...args);\n    return;\n  }\n  console.warn(message, ...args);\n}\n\nfunction attachPreconnect(\n  fetchImpl: FetchLike,\n  baseFetch: FetchLike\n): FetchLike {\n  const upstream = baseFetch as FetchLike & {\n    preconnect?: (input: Parameters<FetchLike>[0], init?: any) => Promise<void>;\n  };\n  const fallbackPreconnect = async () => {};\n  const preconnectFn =\n    typeof upstream.preconnect === 'function'\n      ? upstream.preconnect.bind(baseFetch)\n      : fallbackPreconnect;\n\n  (\n    fetchImpl as FetchLike & {\n      preconnect: typeof preconnectFn;\n    }\n  ).preconnect = preconnectFn;\n  return fetchImpl;\n}\n\nfunction inferChainId(network?: string): number | undefined {\n  if (!network) return undefined;\n  const normalized = network.toLowerCase();\n  if (normalized === 'base' || normalized === 'eip155:8453') return 8453;\n  if (\n    normalized === 'base-sepolia' ||\n    normalized === 'eip155:84532' ||\n    normalized === 'base_testnet'\n  )\n    return 84532;\n  return undefined;\n}\n\nfunction normalizeTypedData(input: TypedDataPayload) {\n  if (!input.primaryType) {\n    throw new Error('[agent-kit] Typed data missing primaryType');\n  }\n  return {\n    domain: input.domain ?? {},\n    types: input.types ?? {},\n    message: input.message ?? {},\n    primaryType: input.primaryType,\n  };\n}\n\nconst toStringMessage = (message: unknown): string => {\n  if (typeof message === 'string') return message;\n  if (typeof (message as any)?.raw === 'string') {\n    return String((message as any).raw);\n  }\n  if (message instanceof Uint8Array) {\n    return Array.from(message)\n      .map(byte => byte.toString(16).padStart(2, '0'))\n      .join('');\n  }\n  if (typeof message === 'object') {\n    return JSON.stringify(message ?? '');\n  }\n  return String(message ?? '');\n};\n\nasync function fetchWalletAddress(\n  wallet: WalletConnector\n): Promise<string | null> {\n  try {\n    const metadata = await wallet.getWalletMetadata();\n    return metadata?.address ?? null;\n  } catch {\n    return null;\n  }\n}\n\nfunction resolveMaxPaymentBaseUnits(\n  override?: bigint,\n  configOverride?: { maxPaymentBaseUnits?: bigint; maxPaymentUsd?: number }\n): bigint | undefined {\n  if (typeof override === 'bigint') return override;\n  if (!configOverride) return undefined;\n\n  if (typeof configOverride.maxPaymentBaseUnits === 'bigint') {\n    return configOverride.maxPaymentBaseUnits;\n  }\n  if (\n    typeof configOverride.maxPaymentUsd === 'number' &&\n    Number.isFinite(configOverride.maxPaymentUsd)\n  ) {\n    const scaled = Math.floor(configOverride.maxPaymentUsd * 1_000_000);\n    return scaled > 0 ? BigInt(scaled) : undefined;\n  }\n  return undefined;\n}\n\nconst normalizeAddressOrNull = (\n  value?: string | null\n): `0x${string}` | null => {\n  const sanitized = sanitizeAddress(value ?? undefined);\n  return sanitized === ZERO_ADDRESS ? null : sanitized;\n};\n\nfunction createRuntimeSigner(opts: {\n  wallet: WalletConnector;\n  initialAddress?: string | null;\n  chainId: number;\n}): RuntimeSigner {\n  let currentAddress = normalizeAddressOrNull(opts.initialAddress);\n  let currentChainId = opts.chainId;\n\n  const signer: RuntimeSigner = {\n    chain: { id: currentChainId },\n    account: { address: currentAddress },\n    transport: { type: 'agent-runtime' },\n    async signTypedData(data: TypedDataPayload) {\n      const typedData = normalizeTypedData(data);\n      const domainChain =\n        (typedData.domain as any)?.chainId ??\n        (typedData.domain as any)?.chain_id;\n      if (typeof domainChain !== 'undefined') {\n        const parsed = Number(domainChain);\n        if (Number.isFinite(parsed) && parsed > 0) {\n          currentChainId = parsed;\n          signer.chain.id = parsed;\n        }\n      }\n\n      // Create a challenge-like payload for typed data signing\n      // The payload should have typedData field for typed data signing\n      const challengePayload = {\n        typedData: {\n          domain: typedData.domain,\n          types: typedData.types,\n          message: typedData.message,\n          primaryType: typedData.primaryType,\n        },\n      };\n\n      // Use signChallenge with a synthetic challenge for typed data\n      const challenge = {\n        id:\n          typeof crypto?.randomUUID === 'function'\n            ? crypto.randomUUID()\n            : globalThis?.crypto?.randomUUID\n              ? globalThis.crypto.randomUUID()\n              : `${Date.now()}-${Math.random()}`,\n        nonce: `${Date.now()}-${Math.random()}`,\n        issued_at: new Date().toISOString(),\n        expires_at: new Date(Date.now() + 3600000).toISOString(),\n        payload: challengePayload,\n        scopes: ['wallet.sign'],\n      };\n\n      const signature = await opts.wallet.signChallenge(challenge);\n\n      // Update address from wallet metadata if available\n      const metadata = await opts.wallet.getWalletMetadata();\n      if (metadata?.address) {\n        const nextAddress = normalizeAddressOrNull(metadata.address);\n        currentAddress = nextAddress ?? currentAddress;\n        signer.account.address = currentAddress;\n      }\n\n      return signature as `0x${string}`;\n    },\n    async signMessage(message: unknown) {\n      const payload = toStringMessage(message);\n\n      // Create a challenge-like payload for message signing\n      // The payload can be a string message directly, or an object with message field\n      const challengePayload = payload;\n\n      // Use signChallenge with a synthetic challenge for message signing\n      const challenge = {\n        id:\n          typeof crypto?.randomUUID === 'function'\n            ? crypto.randomUUID()\n            : globalThis?.crypto?.randomUUID\n              ? globalThis.crypto.randomUUID()\n              : `${Date.now()}-${Math.random()}`,\n        nonce: `${Date.now()}-${Math.random()}`,\n        issued_at: new Date().toISOString(),\n        expires_at: new Date(Date.now() + 3600000).toISOString(),\n        payload: challengePayload,\n        scopes: ['wallet.sign'],\n      };\n\n      const signature = await opts.wallet.signChallenge(challenge);\n\n      // Update address from wallet metadata if available\n      const metadata = await opts.wallet.getWalletMetadata();\n      if (metadata?.address) {\n        const nextAddress = normalizeAddressOrNull(metadata.address);\n        currentAddress = nextAddress ?? currentAddress;\n        signer.account.address = currentAddress;\n      }\n\n      return signature as `0x${string}`;\n    },\n  };\n\n  return signer;\n}\n\nexport async function createRuntimePaymentContext(\n  options: RuntimePaymentOptions\n): Promise<RuntimePaymentContext> {\n  const baseFetch = options.fetch ?? globalThis.fetch;\n  if (!baseFetch) {\n    logWarning(\n      options.logger,\n      '[agent-kit] No fetch implementation available; skipping payment wrapping'\n    );\n    return {\n      fetchWithPayment: null,\n      signer: null,\n      walletAddress: null,\n      chainId: null,\n    };\n  }\n\n  if (options.privateKey) {\n    if (!options.network) {\n      logWarning(\n        options.logger,\n        '[agent-kit-payments] Private key payment context requires options.network'\n      );\n      return {\n        fetchWithPayment: null,\n        signer: null,\n        walletAddress: null,\n        chainId: null,\n      };\n    }\n\n    try {\n      const signer = await createSigner(\n        options.network as any,\n        options.privateKey as any\n      );\n      const fetchWithPayment = attachPreconnect(\n        wrapFetchWithPayment(\n          baseFetch as typeof fetch,\n          signer,\n          resolveMaxPaymentBaseUnits(options.maxPaymentBaseUnits)\n        ) as FetchLike,\n        baseFetch\n      );\n      return {\n        fetchWithPayment,\n        signer,\n        walletAddress: normalizeAddressOrNull(\n          (signer as any)?.account?.address\n        ),\n        chainId:\n          typeof (signer as any)?.chain?.id === 'number'\n            ? (signer as any).chain.id\n            : null,\n      };\n    } catch (error) {\n      logWarning(\n        options.logger,\n        `[agent-kit-payments] Failed to initialise paid fetch with private key: ${\n          (error as Error)?.message ?? error\n        }`\n      );\n      return {\n        fetchWithPayment: null,\n        signer: null,\n        walletAddress: null,\n        chainId: null,\n      };\n    }\n  }\n\n  if (!options.runtime) {\n    logWarning(\n      options.logger,\n      '[agent-kit-payments] Runtime payment context requires either a runtime or private key'\n    );\n    return {\n      fetchWithPayment: null,\n      signer: null,\n      walletAddress: null,\n      chainId: null,\n    };\n  }\n\n  const runtime = options.runtime;\n\n  if (!runtime.wallets?.agent) {\n    logWarning(\n      options.logger,\n      '[agent-kit-payments] Runtime does not have an agent wallet configured'\n    );\n    return {\n      fetchWithPayment: null,\n      signer: null,\n      walletAddress: null,\n      chainId: null,\n    };\n  }\n\n  const wallet = runtime.wallets.agent;\n\n  const chainId = options.chainId ?? inferChainId(options.network);\n  if (!chainId) {\n    logWarning(\n      options.logger,\n      '[agent-kit-payments] Unable to derive chainId for runtime payments; provide options.chainId or options.network'\n    );\n    return {\n      fetchWithPayment: null,\n      signer: null,\n      walletAddress: null,\n      chainId: null,\n    };\n  }\n\n  const walletAddress = await fetchWalletAddress(wallet.connector);\n  const signer = createRuntimeSigner({\n    wallet: wallet.connector,\n    initialAddress: walletAddress,\n    chainId,\n  });\n\n  try {\n    // Wrap base fetch with policy checking if policies are configured\n    let fetchWithPolicy = baseFetch;\n    const policyGroups = runtime.payments?.policyGroups;\n    const paymentTracker = runtime.payments?.paymentTracker as\n      | PaymentTracker\n      | undefined;\n    const rateLimiter = runtime.payments?.rateLimiter as\n      | RateLimiter\n      | undefined;\n\n    if (\n      policyGroups &&\n      policyGroups.length > 0 &&\n      paymentTracker &&\n      rateLimiter\n    ) {\n      fetchWithPolicy = wrapBaseFetchWithPolicy(\n        baseFetch,\n        policyGroups,\n        paymentTracker,\n        rateLimiter\n      );\n    }\n\n    const fetchWithPayment = attachPreconnect(\n      wrapFetchWithPayment(\n        fetchWithPolicy as typeof fetch,\n        signer as unknown as Signer,\n        resolveMaxPaymentBaseUnits(options.maxPaymentBaseUnits)\n      ) as FetchLike,\n      baseFetch\n    );\n    return {\n      fetchWithPayment,\n      signer: signer as unknown as Signer,\n      walletAddress: signer.account.address,\n      chainId,\n    };\n  } catch (error) {\n    logWarning(\n      options.logger,\n      `[agent-kit-payments] Failed to initialise runtime-backed paid fetch: ${\n        (error as Error)?.message ?? error\n      }`\n    );\n    return {\n      fetchWithPayment: null,\n      signer: null,\n      walletAddress: normalizeAddressOrNull(walletAddress),\n      chainId,\n    };\n  }\n}\n","import type { EntrypointDef } from '@lucid-agents/types/core';\nimport type { PaymentsConfig } from '@lucid-agents/types/payments';\n\n/**\n * Resolves the price for an entrypoint.\n * Returns null if no price is explicitly set on the entrypoint.\n */\nexport function resolvePrice(\n  entrypoint: EntrypointDef,\n  payments: PaymentsConfig | undefined,\n  which: 'invoke' | 'stream'\n): string | null {\n  if (!entrypoint.price) {\n    return null;\n  } else if (typeof entrypoint.price === 'string') {\n    return entrypoint.price;\n  } else {\n    return entrypoint.price[which] ?? null;\n  }\n}\n","import type { AgentCardWithEntrypoints, Manifest, PaymentMethod } from '@lucid-agents/types/a2a';\nimport type { EntrypointDef } from '@lucid-agents/types/core';\nimport type { PaymentsConfig } from '@lucid-agents/types/payments';\n\nimport { resolvePrice } from './pricing';\n\n/**\n * Creates a new Agent Card with payments metadata added.\n * Adds pricing to entrypoints and payments array to card.\n * Immutable - returns new card, doesn't mutate input.\n */\nexport function createAgentCardWithPayments(\n  card: AgentCardWithEntrypoints,\n  paymentsConfig: PaymentsConfig,\n  entrypoints: Iterable<EntrypointDef>\n): AgentCardWithEntrypoints {\n  const entrypointList = Array.from(entrypoints);\n  const entrypointsWithPricing: Manifest['entrypoints'] = {};\n\n  // Add pricing to each entrypoint\n  for (const [key, entrypoint] of Object.entries(card.entrypoints)) {\n    const entrypointDef = entrypointList.find(e => e.key === key);\n    if (!entrypointDef) {\n      entrypointsWithPricing[key] = entrypoint;\n      continue;\n    }\n\n    const invP = resolvePrice(entrypointDef, paymentsConfig, 'invoke');\n    const strP = entrypointDef.stream ? resolvePrice(entrypointDef, paymentsConfig, 'stream') : undefined;\n\n    const manifestEntry: Manifest['entrypoints'][string] = {\n      ...entrypoint,\n    };\n\n    if (invP || strP) {\n      const pricing: NonNullable<typeof manifestEntry.pricing> = {};\n      if (invP) pricing.invoke = invP;\n      if (strP) pricing.stream = strP;\n      manifestEntry.pricing = pricing;\n    }\n\n    entrypointsWithPricing[key] = manifestEntry;\n  }\n\n  // Add payments array\n  const paymentMethod: PaymentMethod = {\n    method: 'x402',\n    payee: paymentsConfig.payTo,\n    network: paymentsConfig.network,\n    endpoint: paymentsConfig.facilitatorUrl,\n    extensions: {\n      x402: { facilitatorUrl: paymentsConfig.facilitatorUrl },\n    },\n  };\n\n  return {\n    ...card,\n    entrypoints: entrypointsWithPricing,\n    payments: [paymentMethod],\n  };\n}\n\n","import {\n  SupportedEVMNetworks,\n  SupportedSVMNetworks,\n  type Network,\n} from 'x402/types';\nimport type { PaymentsConfig } from '@lucid-agents/types/payments';\n\nconst SUPPORTED_NETWORKS: Network[] = [\n  ...SupportedEVMNetworks,\n  ...SupportedSVMNetworks,\n];\n\n/**\n * Validates payment configuration and throws descriptive errors if invalid.\n * @param payments - Payment configuration to validate\n * @param network - Network configuration (may be from entrypoint or payments)\n * @param entrypointKey - Entrypoint key for error messages\n * @throws Error if required payment configuration is missing\n */\nexport function validatePaymentsConfig(\n  payments: PaymentsConfig,\n  network: string | undefined,\n  entrypointKey: string\n): void {\n  if (!payments.payTo) {\n    console.error(\n      `[agent-kit] Payment configuration error for entrypoint \"${entrypointKey}\":`,\n      'PAYMENTS_RECEIVABLE_ADDRESS is not set.',\n      'Please set the environment variable or configure payments.payTo in your agent setup.'\n    );\n    throw new Error(\n      `Payment configuration error: PAYMENTS_RECEIVABLE_ADDRESS environment variable is not set. ` +\n        `This is required to receive payments. Please set PAYMENTS_RECEIVABLE_ADDRESS to your wallet address.`\n    );\n  }\n\n  if (!payments.facilitatorUrl) {\n    console.error(\n      `[agent-kit] Payment configuration error for entrypoint \"${entrypointKey}\":`,\n      'FACILITATOR_URL is not set.',\n      'Please set the environment variable or configure payments.facilitatorUrl.'\n    );\n    throw new Error(\n      `Payment configuration error: FACILITATOR_URL environment variable is not set. ` +\n        `This is required for payment processing.`\n    );\n  }\n\n  if (!network) {\n    console.error(\n      `[agent-kit] Payment configuration error for entrypoint \"${entrypointKey}\":`,\n      'NETWORK is not set.',\n      'Please set the NETWORK environment variable or configure payments.network.'\n    );\n    throw new Error(\n      `Payment configuration error: NETWORK is not set. ` +\n        `This is required for payment processing.`\n    );\n  }\n\n  if (!SUPPORTED_NETWORKS.includes(network as Network)) {\n    console.error(\n      `[agent-kit] Payment configuration error for entrypoint \"${entrypointKey}\":`,\n      `Unsupported network: ${network}`,\n      `Supported networks: ${SUPPORTED_NETWORKS.join(', ')}`\n    );\n    throw new Error(\n      `Unsupported payment network: ${network}. ` +\n        `Supported networks: ${SUPPORTED_NETWORKS.join(', ')}. ` +\n        `Please use one of the supported networks in your configuration.`\n    );\n  }\n}\n","import { mkdirSync } from 'fs';\nimport { dirname } from 'path';\nimport { Database } from 'bun:sqlite';\nimport type {\n  PaymentRecord,\n  PaymentDirection,\n} from '@lucid-agents/types/payments';\nimport type { PaymentStorage } from './payment-storage';\n\n/**\n * SQLite payment storage implementation using Bun's native SQLite.\n * Default storage - persistent, zero configuration, auto-creates database.\n * Requires Bun runtime.\n */\nexport class SQLitePaymentStorage implements PaymentStorage {\n  private db: Database;\n\n  constructor(dbPath?: string, agentId?: string) {\n    if (typeof Bun === 'undefined') {\n      throw new Error(\n        'SQLitePaymentStorage requires Bun runtime. Use PostgresPaymentStorage or InMemoryPaymentStorage for Node.js.'\n      );\n    }\n\n    const path = dbPath ?? '.data/payments.db';\n\n    const dir = dirname(path);\n    if (dir && dir !== '.') {\n      try {\n        mkdirSync(dir, { recursive: true });\n      } catch (error) {\n        // Ignore error\n      }\n    }\n\n    this.db = new Database(path);\n    this.initSchema();\n    // Note: agentId is stored but not used for SQLite (single-agent per DB)\n  }\n\n  private initSchema(): void {\n    this.db.exec(`\n      CREATE TABLE IF NOT EXISTS payments (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        agent_id TEXT,\n        group_name TEXT NOT NULL,\n        scope TEXT NOT NULL,\n        direction TEXT NOT NULL,\n        amount TEXT NOT NULL,\n        timestamp INTEGER NOT NULL\n      );\n      CREATE INDEX IF NOT EXISTS idx_agent_group_scope ON payments(agent_id, group_name, scope) WHERE agent_id IS NOT NULL;\n      CREATE INDEX IF NOT EXISTS idx_group_scope ON payments(group_name, scope);\n      CREATE INDEX IF NOT EXISTS idx_timestamp ON payments(timestamp);\n      CREATE INDEX IF NOT EXISTS idx_direction ON payments(direction);\n    `);\n  }\n\n  async recordPayment(\n    record: Omit<PaymentRecord, 'id' | 'timestamp'>\n  ): Promise<void> {\n    const stmt = this.db.prepare(`\n      INSERT INTO payments (group_name, scope, direction, amount, timestamp)\n      VALUES (?, ?, ?, ?, ?)\n    `);\n    stmt.run(\n      record.groupName,\n      record.scope,\n      record.direction,\n      record.amount.toString(),\n      Date.now()\n    );\n    return Promise.resolve();\n  }\n\n  async getTotal(\n    groupName: string,\n    scope: string,\n    direction: PaymentDirection,\n    windowMs?: number\n  ): Promise<bigint> {\n    let query = `\n      SELECT amount\n      FROM payments\n      WHERE group_name = ? AND scope = ? AND direction = ?\n    `;\n\n    let stmt: ReturnType<typeof this.db.prepare>;\n    if (windowMs !== undefined) {\n      query += ' AND timestamp > ?';\n      stmt = this.db.prepare(query);\n      const rows = stmt.all(\n        groupName,\n        scope,\n        direction,\n        Date.now() - windowMs\n      ) as Array<{ amount: string }>;\n      const total = rows.reduce((sum, row) => sum + BigInt(row.amount), 0n);\n      return Promise.resolve(total);\n    } else {\n      stmt = this.db.prepare(query);\n      const rows = stmt.all(groupName, scope, direction) as Array<{\n        amount: string;\n      }>;\n      const total = rows.reduce((sum, row) => sum + BigInt(row.amount), 0n);\n      return Promise.resolve(total);\n    }\n  }\n\n  async getAllRecords(\n    groupName?: string,\n    scope?: string,\n    direction?: PaymentDirection,\n    windowMs?: number\n  ): Promise<PaymentRecord[]> {\n    let query = 'SELECT * FROM payments WHERE 1=1';\n    const conditions: string[] = [];\n    const params: (string | number)[] = [];\n\n    if (groupName) {\n      conditions.push('group_name = ?');\n      params.push(groupName);\n    }\n    if (scope) {\n      conditions.push('scope = ?');\n      params.push(scope);\n    }\n    if (direction) {\n      conditions.push('direction = ?');\n      params.push(direction);\n    }\n    if (windowMs !== undefined) {\n      conditions.push('timestamp > ?');\n      params.push(Date.now() - windowMs);\n    }\n\n    if (conditions.length > 0) {\n      query += ' AND ' + conditions.join(' AND ');\n    }\n\n    query += ' ORDER BY timestamp DESC';\n\n    const stmt = this.db.prepare(query);\n    // Bun's SQLite all() returns unknown[], so we type the result based on our query schema\n    // This is safe because we control the query and know the row structure\n    type SQLiteRow = {\n      id: number;\n      agent_id?: string | null;\n      group_name: string;\n      scope: string;\n      direction: string;\n      amount: string;\n      timestamp: number;\n    };\n\n    let result: unknown[];\n    if (params.length === 0) {\n      result = stmt.all();\n    } else if (params.length === 1) {\n      result = stmt.all(params[0]);\n    } else if (params.length === 2) {\n      result = stmt.all(params[0], params[1]);\n    } else if (params.length === 3) {\n      result = stmt.all(params[0], params[1], params[2]);\n    } else {\n      result = stmt.all(params[0], params[1], params[2], params[3]);\n    }\n\n    // Type assertion is necessary here because Bun's SQLite returns unknown[]\n    // We know the structure from our query, so this is safe\n    const rows = result as SQLiteRow[];\n\n    return Promise.resolve(\n      rows.map(row => ({\n        id: row.id,\n        groupName: row.group_name,\n        scope: row.scope,\n        direction: row.direction as PaymentDirection,\n        amount: BigInt(row.amount),\n        timestamp: row.timestamp,\n      }))\n    );\n  }\n\n  async clear(): Promise<void> {\n    this.db.exec('DELETE FROM payments');\n    return Promise.resolve();\n  }\n\n  /**\n   * Closes the database connection.\n   * Should be called when the storage is no longer needed.\n   */\n  close(): void {\n    this.db.close();\n  }\n}\n\n/**\n * Creates a new SQLite payment storage instance.\n * @param dbPath - Optional custom database path (defaults to `.data/payments.db`)\n * @param agentId - Optional agent ID (not used for SQLite, kept for API consistency)\n * @returns A new SQLitePaymentStorage instance\n * @throws Error if not running in Bun runtime\n */\nexport function createSQLitePaymentStorage(\n  dbPath?: string,\n  agentId?: string\n): PaymentStorage {\n  return new SQLitePaymentStorage(dbPath, agentId);\n}\n","import type { PaymentDirection, PaymentTracker as PaymentTrackerInterface } from '@lucid-agents/types/payments';\nimport type { PaymentStorage } from './payment-storage';\nimport { createSQLitePaymentStorage } from './sqlite-payment-storage';\n\n/**\n * Formats a BigInt amount (in base units with 6 decimals) to a human-friendly USDC string.\n * @param amount - Amount in base units (USDC has 6 decimals)\n * @returns Formatted string (e.g., \"1.5\" for 1.5 USDC, \"1\" for 1.0 USDC)\n */\nfunction formatUsdcAmount(amount: bigint): string {\n  const usdc = Number(amount) / 1_000_000;\n  return usdc.toFixed(6).replace(/\\.?0+$/, '');\n}\n\n/**\n * Tracks payments (both outgoing and incoming) per policy group and scope.\n * Uses storage abstraction to support different backends (SQLite, In-Memory, Postgres).\n */\nexport class PaymentTracker implements PaymentTrackerInterface {\n  constructor(private storage: PaymentStorage) {}\n\n  /**\n   * Checks if an outgoing payment limit would be exceeded.\n   * @param groupName - Policy group name\n   * @param scope - Scope key (\"global\", target URL, or endpoint URL)\n   * @param maxTotalUsd - Maximum total spending in USD\n   * @param windowMs - Optional time window in milliseconds (if not provided, lifetime limit)\n   * @param requestedAmount - Amount requested in base units (USDC has 6 decimals)\n   * @returns Result indicating if allowed and current total\n   */\n  async checkOutgoingLimit(\n    groupName: string,\n    scope: string,\n    maxTotalUsd: number,\n    windowMs: number | undefined,\n    requestedAmount: bigint\n  ): Promise<{ allowed: boolean; reason?: string; currentTotal?: bigint }> {\n    const maxTotalBaseUnits = BigInt(Math.floor(maxTotalUsd * 1_000_000));\n\n    const currentTotal = await this.storage.getTotal(\n      groupName,\n      scope,\n      'outgoing',\n      windowMs\n    );\n\n    const newTotal = currentTotal + requestedAmount;\n    if (newTotal > maxTotalBaseUnits) {\n      return {\n        allowed: false,\n        reason: `Total outgoing payment limit exceeded for policy group \"${groupName}\" at scope \"${scope}\". Current: ${formatUsdcAmount(currentTotal)} USDC, Requested: ${formatUsdcAmount(requestedAmount)} USDC, Limit: ${maxTotalUsd} USDC`,\n        currentTotal,\n      };\n    }\n\n    return {\n      allowed: true,\n      currentTotal,\n    };\n  }\n\n  /**\n   * Checks if an incoming payment limit would be exceeded.\n   * @param groupName - Policy group name\n   * @param scope - Scope key (\"global\", sender address, or endpoint URL)\n   * @param maxTotalUsd - Maximum total incoming in USD\n   * @param windowMs - Optional time window in milliseconds (if not provided, lifetime limit)\n   * @param requestedAmount - Amount requested in base units (USDC has 6 decimals)\n   * @returns Result indicating if allowed and current total\n   */\n  async checkIncomingLimit(\n    groupName: string,\n    scope: string,\n    maxTotalUsd: number,\n    windowMs: number | undefined,\n    requestedAmount: bigint\n  ): Promise<{ allowed: boolean; reason?: string; currentTotal?: bigint }> {\n    const maxTotalBaseUnits = BigInt(Math.floor(maxTotalUsd * 1_000_000));\n\n    const currentTotal = await this.storage.getTotal(\n      groupName,\n      scope,\n      'incoming',\n      windowMs\n    );\n\n    const newTotal = currentTotal + requestedAmount;\n    if (newTotal > maxTotalBaseUnits) {\n      return {\n        allowed: false,\n        reason: `Total incoming payment limit exceeded for policy group \"${groupName}\" at scope \"${scope}\". Current: ${formatUsdcAmount(currentTotal)} USDC, Requested: ${formatUsdcAmount(requestedAmount)} USDC, Limit: ${maxTotalUsd} USDC`,\n        currentTotal,\n      };\n    }\n\n    return {\n      allowed: true,\n      currentTotal,\n    };\n  }\n\n  /**\n   * Records an outgoing payment after a successful payment.\n   * @param groupName - Policy group name\n   * @param scope - Scope key (\"global\", target URL, or endpoint URL)\n   * @param amount - Amount spent in base units\n   */\n  async recordOutgoing(groupName: string, scope: string, amount: bigint): Promise<void> {\n    await this.storage.recordPayment({\n      groupName,\n      scope,\n      direction: 'outgoing',\n      amount,\n    });\n  }\n\n  /**\n   * Records an incoming payment after a successful payment.\n   * @param groupName - Policy group name\n   * @param scope - Scope key (\"global\", sender address, or endpoint URL)\n   * @param amount - Amount received in base units\n   */\n  async recordIncoming(groupName: string, scope: string, amount: bigint): Promise<void> {\n    await this.storage.recordPayment({\n      groupName,\n      scope,\n      direction: 'incoming',\n      amount,\n    });\n  }\n\n  /**\n   * Gets the current total outgoing payments for a scope (for informational purposes).\n   * @param groupName - Policy group name\n   * @param scope - Scope key\n   * @param windowMs - Optional time window to filter entries\n   * @returns Current total in base units\n   */\n  async getOutgoingTotal(\n    groupName: string,\n    scope: string,\n    windowMs?: number\n  ): Promise<bigint> {\n    return await this.storage.getTotal(groupName, scope, 'outgoing', windowMs);\n  }\n\n  /**\n   * Gets the current total incoming payments for a scope (for informational purposes).\n   * @param groupName - Policy group name\n   * @param scope - Scope key\n   * @param windowMs - Optional time window to filter entries\n   * @returns Current total in base units\n   */\n  async getIncomingTotal(\n    groupName: string,\n    scope: string,\n    windowMs?: number\n  ): Promise<bigint> {\n    return await this.storage.getTotal(groupName, scope, 'incoming', windowMs);\n  }\n\n  /**\n   * Gets all payment data (both outgoing and incoming).\n   * @returns Array of all payment records\n   */\n  async getAllData() {\n    return await this.storage.getAllRecords();\n  }\n\n  /**\n   * Clears all payment data (useful for testing or reset).\n   */\n  async clear(): Promise<void> {\n    await this.storage.clear();\n  }\n}\n\n/**\n * Creates a new payment tracker instance.\n * Defaults to SQLite storage if no storage is provided.\n * @param storage - Optional storage implementation (defaults to SQLite)\n * @returns A new PaymentTracker instance\n */\nexport function createPaymentTracker(storage?: PaymentStorage): PaymentTracker {\n  const storageImpl = storage ?? createSQLitePaymentStorage();\n  return new PaymentTracker(storageImpl);\n}\n","/**\n * Rate limiter for tracking payments per time window per policy group.\n * Uses sliding window approach (in-memory).\n * All state is lost on restart - this is acceptable for now.\n *\n * Tracks payment timestamps per policy group and enforces rate limits\n * based on maximum payments allowed within a time window.\n */\nclass RateLimiter {\n  private payments: Map<string, number[]> = new Map();\n\n  /**\n   * Checks if a payment would exceed the rate limit.\n   * @param groupName - Policy group name\n   * @param maxPayments - Maximum number of payments allowed\n   * @param windowMs - Time window in milliseconds\n   * @returns Result indicating if allowed\n   */\n  checkLimit(\n    groupName: string,\n    maxPayments: number,\n    windowMs: number\n  ): { allowed: boolean; reason?: string } {\n    const now = Date.now();\n    const cutoff = now - windowMs;\n\n    let timestamps = this.payments.get(groupName);\n    if (!timestamps) {\n      timestamps = [];\n      this.payments.set(groupName, timestamps);\n    }\n\n    const validTimestamps = timestamps.filter(ts => ts > cutoff);\n    this.payments.set(groupName, validTimestamps);\n\n    if (validTimestamps.length >= maxPayments) {\n      return {\n        allowed: false,\n        reason: `Rate limit exceeded for policy group \"${groupName}\". ${validTimestamps.length} payments in the last ${windowMs}ms, limit is ${maxPayments}`,\n      };\n    }\n\n    return { allowed: true };\n  }\n\n  /**\n   * Records a payment after successful execution.\n   * @param groupName - Policy group name\n   */\n  recordPayment(groupName: string): void {\n    const now = Date.now();\n\n    let timestamps = this.payments.get(groupName);\n    if (!timestamps) {\n      timestamps = [];\n      this.payments.set(groupName, timestamps);\n    }\n\n    timestamps.push(now);\n  }\n\n  /**\n   * Gets the current count of payments within the window (for informational purposes).\n   * @param groupName - Policy group name\n   * @param windowMs - Time window in milliseconds\n   * @returns Current count of payments\n   */\n  getCurrentCount(groupName: string, windowMs: number): number {\n    const now = Date.now();\n    const cutoff = now - windowMs;\n\n    const timestamps = this.payments.get(groupName);\n    if (!timestamps) {\n      return 0;\n    }\n\n    return timestamps.filter(ts => ts > cutoff).length;\n  }\n\n  /**\n   * Clears all rate limit data (useful for testing or reset).\n   */\n  clear(): void {\n    this.payments.clear();\n  }\n}\n\nexport type { RateLimiter };\n\n/**\n * Creates a new rate limiter instance.\n * @returns A new RateLimiter instance for tracking payment rate limits\n */\nexport function createRateLimiter(): RateLimiter {\n  return new RateLimiter();\n}\n","import type { PaymentRecord, PaymentDirection } from '@lucid-agents/types/payments';\nimport type { PaymentStorage } from './payment-storage';\n\ntype PaymentEntry = {\n  amount: bigint;\n  timestamp: number;\n};\n\ntype ScopeKey = string;\n\n/**\n * In-memory payment storage using Map data structure.\n * Data is ephemeral (lost on restart/invocation).\n * Useful for serverless without file access, testing, temporary tracking.\n */\nexport class InMemoryPaymentStorage implements PaymentStorage {\n  private payments: Map<string, Map<ScopeKey, PaymentEntry[]>> = new Map();\n\n  async recordPayment(\n    record: Omit<PaymentRecord, 'id' | 'timestamp'>\n  ): Promise<void> {\n    const key = `${record.groupName}:${record.direction}`;\n    let groupPayments = this.payments.get(key);\n    if (!groupPayments) {\n      groupPayments = new Map();\n      this.payments.set(key, groupPayments);\n    }\n\n    let entries = groupPayments.get(record.scope);\n    if (!entries) {\n      entries = [];\n      groupPayments.set(record.scope, entries);\n    }\n\n    entries.push({\n      amount: record.amount,\n      timestamp: Date.now(),\n    });\n    return Promise.resolve();\n  }\n\n  async getTotal(\n    groupName: string,\n    scope: string,\n    direction: PaymentDirection,\n    windowMs?: number\n  ): Promise<bigint> {\n    const key = `${groupName}:${direction}`;\n    const groupPayments = this.payments.get(key);\n    if (!groupPayments) {\n      return Promise.resolve(0n);\n    }\n\n    let entries = groupPayments.get(scope);\n    if (!entries || entries.length === 0) {\n      return Promise.resolve(0n);\n    }\n\n    if (windowMs !== undefined) {\n      const cutoff = Date.now() - windowMs;\n      entries = entries.filter(entry => entry.timestamp > cutoff);\n    }\n\n    return Promise.resolve(\n      entries.reduce((sum, entry) => sum + entry.amount, 0n)\n    );\n  }\n\n  async getAllRecords(\n    groupName?: string,\n    scope?: string,\n    direction?: PaymentDirection,\n    windowMs?: number\n  ): Promise<PaymentRecord[]> {\n    const records: PaymentRecord[] = [];\n    const cutoff = windowMs !== undefined ? Date.now() - windowMs : undefined;\n\n    for (const [key, groupPayments] of this.payments.entries()) {\n      const lastColonIndex = key.lastIndexOf(':');\n      if (lastColonIndex === -1) {\n        continue;\n      }\n\n      const keyGroupName = key.substring(0, lastColonIndex);\n      const keyDirection = key.substring(\n        lastColonIndex + 1\n      ) as PaymentDirection;\n\n      if (groupName && keyGroupName !== groupName) {\n        continue;\n      }\n      if (direction && keyDirection !== direction) {\n        continue;\n      }\n\n      for (const [keyScope, entries] of groupPayments.entries()) {\n        if (scope && keyScope !== scope) {\n          continue;\n        }\n\n        const filteredEntries =\n          cutoff !== undefined\n            ? entries.filter(entry => entry.timestamp > cutoff)\n            : entries;\n\n        for (const entry of filteredEntries) {\n          records.push({\n            groupName: keyGroupName,\n            scope: keyScope,\n            direction: keyDirection,\n            amount: entry.amount,\n            timestamp: entry.timestamp,\n          });\n        }\n      }\n    }\n\n    return Promise.resolve(records);\n  }\n\n  async clear(): Promise<void> {\n    this.payments.clear();\n    return Promise.resolve();\n  }\n}\n\n/**\n * Creates a new in-memory payment storage instance.\n * @returns A new InMemoryPaymentStorage instance\n */\nexport function createInMemoryPaymentStorage(): PaymentStorage {\n  return new InMemoryPaymentStorage();\n}\n","import { Pool } from 'pg';\nimport type {\n  PaymentRecord,\n  PaymentDirection,\n} from '@lucid-agents/types/payments';\nimport type { PaymentStorage } from './payment-storage';\n\n/**\n * Postgres payment storage implementation.\n * For serverless with persistence needs, multi-agent deployments.\n */\nexport class PostgresPaymentStorage implements PaymentStorage {\n  private pool: Pool;\n  private schemaInitialized = false;\n  private agentId?: string;\n\n  constructor(connectionString: string, agentId?: string) {\n    this.pool = new Pool({\n      connectionString,\n      max: 10,\n      idleTimeoutMillis: 30000,\n      connectionTimeoutMillis: 5000,\n    });\n    this.agentId = agentId;\n  }\n\n  private async initSchema(): Promise<void> {\n    if (this.schemaInitialized) {\n      return;\n    }\n\n    const client = await this.pool.connect();\n    try {\n      await client.query(`\n        CREATE TABLE IF NOT EXISTS payments (\n          id SERIAL PRIMARY KEY,\n          agent_id TEXT,\n          group_name VARCHAR NOT NULL,\n          scope VARCHAR NOT NULL,\n          direction VARCHAR NOT NULL,\n          amount BIGINT NOT NULL,\n          timestamp BIGINT NOT NULL\n        );\n        CREATE INDEX IF NOT EXISTS idx_agent_group_scope ON payments(agent_id, group_name, scope) WHERE agent_id IS NOT NULL;\n        CREATE INDEX IF NOT EXISTS idx_group_scope ON payments(group_name, scope);\n        CREATE INDEX IF NOT EXISTS idx_timestamp ON payments(timestamp);\n        CREATE INDEX IF NOT EXISTS idx_direction ON payments(direction);\n      `);\n      this.schemaInitialized = true;\n    } finally {\n      client.release();\n    }\n  }\n\n  async recordPayment(\n    record: Omit<PaymentRecord, 'id' | 'timestamp'>\n  ): Promise<void> {\n    if (!this.schemaInitialized) {\n      await this.initSchema();\n    }\n\n    try {\n      if (this.agentId) {\n        await this.pool.query(\n          `\n          INSERT INTO payments (agent_id, group_name, scope, direction, amount, timestamp)\n          VALUES ($1, $2, $3, $4, $5, $6)\n        `,\n          [\n            this.agentId,\n            record.groupName,\n            record.scope,\n            record.direction,\n            record.amount.toString(),\n            Date.now(),\n          ]\n        );\n      } else {\n        await this.pool.query(\n          `\n          INSERT INTO payments (agent_id, group_name, scope, direction, amount, timestamp)\n          VALUES (NULL, $1, $2, $3, $4, $5)\n        `,\n          [\n            record.groupName,\n            record.scope,\n            record.direction,\n            record.amount.toString(),\n            Date.now(),\n          ]\n        );\n      }\n    } catch (error) {\n      console.error('[PostgresPaymentStorage] Error recording payment:', error);\n      throw error;\n    }\n  }\n\n  async getTotal(\n    groupName: string,\n    scope: string,\n    direction: PaymentDirection,\n    windowMs?: number\n  ): Promise<bigint> {\n    try {\n      if (!this.schemaInitialized) {\n        await this.initSchema();\n      }\n\n      let query: string;\n      const params: unknown[] = [];\n      let paramIndex = 1;\n\n      if (this.agentId) {\n        query = `\n          SELECT SUM(amount) as total\n          FROM payments\n          WHERE agent_id = $${paramIndex} AND group_name = $${paramIndex + 1} AND scope = $${paramIndex + 2} AND direction = $${paramIndex + 3}\n        `;\n        params.push(this.agentId, groupName, scope, direction);\n        paramIndex += 4;\n      } else {\n        query = `\n          SELECT SUM(amount) as total\n          FROM payments\n          WHERE agent_id IS NULL AND group_name = $${paramIndex} AND scope = $${paramIndex + 1} AND direction = $${paramIndex + 2}\n        `;\n        params.push(groupName, scope, direction);\n        paramIndex += 3;\n      }\n\n      if (windowMs !== undefined) {\n        query += ` AND timestamp > $${paramIndex}`;\n        params.push(Date.now() - windowMs);\n      }\n\n      const queryResult = await this.pool.query(query, params);\n      const total = queryResult.rows[0]?.total;\n      return total ? BigInt(total) : 0n;\n    } catch (error) {\n      console.error('[PostgresPaymentStorage] Error getting total:', error);\n      return 0n;\n    }\n  }\n\n  async getAllRecords(\n    groupName?: string,\n    scope?: string,\n    direction?: PaymentDirection,\n    windowMs?: number\n  ): Promise<PaymentRecord[]> {\n    try {\n      if (!this.schemaInitialized) {\n        await this.initSchema();\n      }\n\n      let query = 'SELECT * FROM payments WHERE 1=1';\n      const params: unknown[] = [];\n      let paramIndex = 1;\n\n      if (this.agentId) {\n        query += ` AND agent_id = $${paramIndex}`;\n        params.push(this.agentId);\n        paramIndex++;\n      } else {\n        query += ` AND agent_id IS NULL`;\n      }\n      if (groupName) {\n        query += ` AND group_name = $${paramIndex}`;\n        params.push(groupName);\n        paramIndex++;\n      }\n      if (scope) {\n        query += ` AND scope = $${paramIndex}`;\n        params.push(scope);\n        paramIndex++;\n      }\n      if (direction) {\n        query += ` AND direction = $${paramIndex}`;\n        params.push(direction);\n        paramIndex++;\n      }\n      if (windowMs !== undefined) {\n        query += ` AND timestamp > $${paramIndex}`;\n        params.push(Date.now() - windowMs);\n        paramIndex++;\n      }\n\n      query += ' ORDER BY timestamp DESC';\n\n      const queryResult = await this.pool.query(query, params);\n\n      return queryResult.rows.map(row => ({\n        id: row.id,\n        groupName: row.group_name,\n        scope: row.scope,\n        direction: row.direction as PaymentDirection,\n        amount: BigInt(row.amount),\n        timestamp: Number(row.timestamp),\n      }));\n    } catch (error) {\n      console.error('[PostgresPaymentStorage] Error getting records:', error);\n      return [];\n    }\n  }\n\n  async clear(): Promise<void> {\n    try {\n      if (!this.schemaInitialized) {\n        await this.initSchema();\n      }\n      if (this.agentId) {\n        await this.pool.query('DELETE FROM payments WHERE agent_id = $1', [\n          this.agentId,\n        ]);\n      } else {\n        await this.pool.query('DELETE FROM payments');\n      }\n    } catch (error) {\n      console.error('[PostgresPaymentStorage] Error clearing payments:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Closes the connection pool.\n   * Should be called when the storage is no longer needed.\n   */\n  async close(): Promise<void> {\n    await this.pool.end();\n  }\n}\n\n/**\n * Creates a new Postgres payment storage instance.\n * @param connectionString - Postgres connection string\n * @param agentId - Optional agent ID for multi-agent platforms (filters transactions by agent)\n * @returns A new PostgresPaymentStorage instance\n */\nexport function createPostgresPaymentStorage(\n  connectionString: string,\n  agentId?: string\n): PaymentStorage {\n  return new PostgresPaymentStorage(connectionString, agentId);\n}\n","import type { Network } from 'x402/types';\nimport type {\n  EntrypointDef,\n  AgentCore,\n  AgentRuntime,\n} from '@lucid-agents/types/core';\nimport type { EntrypointPrice } from '@lucid-agents/types/payments';\nimport type {\n  PaymentsConfig,\n  PaymentRequirement,\n  RuntimePaymentRequirement,\n  PaymentPolicyGroup,\n  PaymentsRuntime,\n  PaymentStorageConfig,\n} from '@lucid-agents/types/payments';\nimport { resolvePrice } from './pricing';\nimport { createPaymentTracker, type PaymentTracker } from './payment-tracker';\nimport { createRateLimiter, type RateLimiter } from './rate-limiter';\nimport { createSQLitePaymentStorage } from './sqlite-payment-storage';\nimport { createInMemoryPaymentStorage } from './in-memory-payment-storage';\nimport { createPostgresPaymentStorage } from './postgres-payment-storage';\nimport type { PaymentStorage } from './payment-storage';\n\n/**\n * Checks if an entrypoint has an explicit price set.\n */\nexport function entrypointHasExplicitPrice(entrypoint: EntrypointDef): boolean {\n  const { price } = entrypoint;\n  if (typeof price === 'string') {\n    return price.trim().length > 0;\n  }\n  if (price && typeof price === 'object') {\n    const hasInvoke = price.invoke;\n    const hasStream = price.stream;\n    const invokeDefined =\n      typeof hasInvoke === 'string'\n        ? hasInvoke.trim().length > 0\n        : hasInvoke !== undefined;\n    const streamDefined =\n      typeof hasStream === 'string'\n        ? hasStream.trim().length > 0\n        : hasStream !== undefined;\n    return invokeDefined || streamDefined;\n  }\n  return false;\n}\n\n/**\n * Resolves active payments configuration for an entrypoint.\n * Activates payments if the entrypoint has an explicit price and payments config is available.\n */\nexport function resolveActivePayments(\n  entrypoint: EntrypointDef,\n  paymentsOption: PaymentsConfig | false | undefined,\n  resolvedPayments: PaymentsConfig | undefined,\n  currentActivePayments: PaymentsConfig | undefined\n): PaymentsConfig | undefined {\n  // If payments are explicitly disabled, return undefined\n  if (paymentsOption === false) {\n    return undefined;\n  }\n\n  // If payments are already active, keep them active\n  if (currentActivePayments) {\n    return currentActivePayments;\n  }\n\n  // If entrypoint has no explicit price, don't activate payments\n  if (!entrypointHasExplicitPrice(entrypoint)) {\n    return undefined;\n  }\n\n  // If no resolved payments config, don't activate\n  if (!resolvedPayments) {\n    return undefined;\n  }\n\n  // Activate payments for this entrypoint\n  return { ...resolvedPayments };\n}\n\n/**\n * Evaluates payment requirement for an entrypoint and returns HTTP response if needed.\n */\nexport function evaluatePaymentRequirement(\n  entrypoint: EntrypointDef,\n  kind: 'invoke' | 'stream',\n  activePayments: PaymentsConfig | undefined\n): RuntimePaymentRequirement {\n  const requirement = resolvePaymentRequirement(\n    entrypoint,\n    kind,\n    activePayments\n  );\n  if (requirement.required) {\n    const requiredRequirement = requirement as Extract<\n      PaymentRequirement,\n      { required: true }\n    >;\n    const enriched: RuntimePaymentRequirement = {\n      ...requiredRequirement,\n      response: paymentRequiredResponse(requiredRequirement),\n    };\n    return enriched;\n  }\n  return requirement as RuntimePaymentRequirement;\n}\n\nexport const resolvePaymentRequirement = (\n  entrypoint: EntrypointDef,\n  kind: 'invoke' | 'stream',\n  payments?: PaymentsConfig\n): PaymentRequirement => {\n  if (!payments) {\n    return { required: false };\n  }\n\n  const network = entrypoint.network ?? payments.network;\n  if (!network) {\n    return { required: false };\n  }\n\n  const price = resolvePrice(entrypoint, payments, kind);\n  if (!price) {\n    return { required: false };\n  }\n\n  return {\n    required: true,\n    payTo: payments.payTo,\n    price,\n    network,\n    facilitatorUrl: payments.facilitatorUrl,\n  };\n};\n\nexport const paymentRequiredResponse = (\n  requirement: Extract<PaymentRequirement, { required: true }>\n) => {\n  const headers = new Headers({\n    'Content-Type': 'application/json; charset=utf-8',\n    'X-Price': requirement.price,\n    'X-Network': requirement.network,\n    'X-Pay-To': requirement.payTo,\n  });\n  if (requirement.facilitatorUrl) {\n    headers.set('X-Facilitator', requirement.facilitatorUrl);\n  }\n  return new Response(\n    JSON.stringify({\n      error: {\n        code: 'payment_required',\n        price: requirement.price,\n        network: requirement.network,\n        payTo: requirement.payTo,\n      },\n    }),\n    {\n      status: 402,\n      headers,\n    }\n  );\n};\n\n/**\n * Creates payment storage based on configuration.\n * Defaults to SQLite if no storage config is provided.\n * @param storageConfig - Storage configuration\n * @param agentId - Optional agent ID for multi-agent platforms (only used for Postgres)\n */\nfunction createStorageFromConfig(\n  storageConfig?: PaymentStorageConfig,\n  agentId?: string\n): PaymentStorage {\n  if (!storageConfig) {\n    // Default: SQLite\n    return createSQLitePaymentStorage();\n  }\n\n  switch (storageConfig.type) {\n    case 'in-memory':\n      return createInMemoryPaymentStorage();\n    case 'postgres':\n      if (!storageConfig.postgres?.connectionString) {\n        throw new Error(\n          'Postgres storage requires connectionString in postgres config'\n        );\n      }\n      return createPostgresPaymentStorage(\n        storageConfig.postgres.connectionString,\n        agentId\n      );\n    case 'sqlite':\n    default:\n      return createSQLitePaymentStorage(storageConfig.sqlite?.dbPath);\n  }\n}\n\nexport function createPaymentsRuntime(\n  paymentsOption: PaymentsConfig | false | undefined,\n  agentId?: string,\n  customStorageFactory?: (\n    storageConfig?: PaymentStorageConfig,\n    agentId?: string\n  ) => PaymentStorage\n): PaymentsRuntime | undefined {\n  const config: PaymentsConfig | undefined =\n    paymentsOption === false ? undefined : paymentsOption;\n\n  if (!config) {\n    return undefined;\n  }\n\n  let isActive = false;\n\n  // Create storage and payment tracker\n  let paymentTracker: PaymentTracker | undefined;\n  let rateLimiter: RateLimiter | undefined;\n\n  const policyGroups = config.policyGroups;\n\n  try {\n    const storage = customStorageFactory\n      ? customStorageFactory(config.storage, agentId)\n      : createStorageFromConfig(config.storage, agentId);\n    paymentTracker = createPaymentTracker(storage);\n  } catch (error) {\n    throw new Error(\n      `Failed to initialize payment storage: ${(error as Error).message}`\n    );\n  }\n\n  if (policyGroups && policyGroups.length > 0) {\n    const needsRateLimiter = policyGroups.some(\n      group => group.rateLimits !== undefined\n    );\n\n    if (needsRateLimiter) {\n      rateLimiter = createRateLimiter();\n    }\n  }\n\n  return {\n    get config() {\n      return config;\n    },\n    get isActive() {\n      return isActive;\n    },\n    get paymentTracker() {\n      return paymentTracker;\n    },\n    get rateLimiter() {\n      return rateLimiter;\n    },\n    get policyGroups() {\n      return policyGroups;\n    },\n    requirements(entrypoint: EntrypointDef, kind: 'invoke' | 'stream') {\n      return evaluatePaymentRequirement(\n        entrypoint,\n        kind,\n        isActive ? config : undefined\n      );\n    },\n    activate(entrypoint: EntrypointDef) {\n      if (isActive || !config) return;\n\n      if (entrypointHasExplicitPrice(entrypoint)) {\n        isActive = true;\n      }\n    },\n    resolvePrice(entrypoint: EntrypointDef, which: 'invoke' | 'stream') {\n      return resolvePrice(entrypoint, config, which);\n    },\n    async getFetchWithPayment(\n      runtime: AgentRuntime,\n      network?: string\n    ): Promise<\n      | ((input: RequestInfo | URL, init?: RequestInit) => Promise<Response>)\n      | null\n    > {\n      const { createRuntimePaymentContext } = await import('./runtime');\n      const paymentContext = await createRuntimePaymentContext({\n        runtime,\n        network,\n      });\n      return paymentContext.fetchWithPayment as\n        | ((input: RequestInfo | URL, init?: RequestInit) => Promise<Response>)\n        | null;\n    },\n  };\n}\n","export { resolvePrice } from './pricing';\nexport { createAgentCardWithPayments } from './manifest';\nexport { validatePaymentsConfig } from './validation';\nexport {\n  entrypointHasExplicitPrice,\n  evaluatePaymentRequirement,\n  resolveActivePayments,\n  resolvePaymentRequirement,\n  paymentRequiredResponse,\n  createPaymentsRuntime,\n} from './payments';\nexport {\n  createRuntimePaymentContext,\n  type RuntimePaymentContext,\n  type RuntimePaymentLogger,\n  type RuntimePaymentOptions,\n} from './runtime';\nexport {\n  paymentsFromEnv,\n  extractSenderDomain,\n  extractPayerAddress,\n  parsePriceAmount,\n} from './utils';\nexport {\n  createX402Fetch,\n  accountFromPrivateKey,\n  createX402LLM,\n  x402LLM,\n  type CreateX402FetchOptions,\n  type CreateX402LLMOptions,\n  type WrappedFetch,\n  type X402Account,\n} from './x402';\nexport {\n  sanitizeAddress,\n  normalizeAddress,\n  ZERO_ADDRESS,\n  type Hex,\n} from './crypto';\nexport { payments } from './extension';\nexport { createPaymentTracker, type PaymentTracker } from './payment-tracker';\nexport type { PaymentStorage } from './payment-storage';\nexport {\n  createSQLitePaymentStorage,\n  type SQLitePaymentStorage,\n} from './sqlite-payment-storage';\nexport {\n  createInMemoryPaymentStorage,\n  type InMemoryPaymentStorage,\n} from './in-memory-payment-storage';\nexport {\n  createPostgresPaymentStorage,\n  type PostgresPaymentStorage,\n} from './postgres-payment-storage';\nexport { createRateLimiter, type RateLimiter } from './rate-limiter';\nexport {\n  evaluatePolicyGroups,\n  evaluateIncomingPolicyGroups,\n  evaluateRecipient,\n  evaluateSender,\n  evaluateRateLimit,\n  evaluateOutgoingLimits,\n  evaluateIncomingLimits,\n  findMostSpecificOutgoingLimit,\n  findMostSpecificIncomingLimit,\n  type PolicyEvaluationResult,\n} from './policy';\nexport { wrapBaseFetchWithPolicy } from './policy-wrapper';\n","import type { PaymentsConfig } from '@lucid-agents/types/payments';\n\n/**\n * Creates PaymentsConfig from environment variables and optional overrides.\n *\n * @param configOverrides - Optional config overrides from agent-kit config\n * @returns PaymentsConfig resolved from env + overrides\n */\nexport function paymentsFromEnv(\n  configOverrides?: Partial<PaymentsConfig>\n): PaymentsConfig {\n  const baseConfig: PaymentsConfig = {\n    payTo: configOverrides?.payTo ?? (process.env.PAYMENTS_RECEIVABLE_ADDRESS as any),\n    facilitatorUrl: configOverrides?.facilitatorUrl ?? (process.env.FACILITATOR_URL as any),\n    network: configOverrides?.network ?? (process.env.NETWORK as any),\n  };\n\n  return {\n    ...baseConfig,\n    ...configOverrides,\n  };\n}\n\n/**\n * Extracts domain from a URL string or request headers.\n * @param urlOrOrigin - URL string or origin header value\n * @param referer - Optional referer header value\n * @returns Domain hostname or undefined\n */\nexport function extractSenderDomain(\n  urlOrOrigin?: string | null,\n  referer?: string | null\n): string | undefined {\n  if (urlOrOrigin) {\n    try {\n      return new URL(urlOrOrigin).hostname;\n    } catch {\n      // Invalid URL\n    }\n  }\n  if (referer) {\n    try {\n      return new URL(referer).hostname;\n    } catch {\n      // Invalid referer\n    }\n  }\n  return undefined;\n}\n\n/**\n * Extracts payer address from X-PAYMENT-RESPONSE header.\n * @param paymentResponseHeader - Base64-encoded JSON payment response header\n * @returns Payer address or undefined\n */\nexport function extractPayerAddress(\n  paymentResponseHeader: string | null | undefined\n): string | undefined {\n  if (!paymentResponseHeader) return undefined;\n\n  try {\n    const decoded = JSON.parse(\n      Buffer.from(paymentResponseHeader, 'base64').toString('utf-8')\n    );\n    return decoded.payer;\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * Parses payment amount from price string (assumes USDC with 6 decimals).\n * @param price - Price string (e.g., \"1.5\" for $1.50)\n * @returns Amount in base units (with 6 decimals), or undefined if invalid\n */\nexport function parsePriceAmount(price: string): bigint | undefined {\n  try {\n    const priceNum = parseFloat(price);\n    if (!Number.isFinite(priceNum) || priceNum < 0) return undefined;\n    return BigInt(Math.floor(priceNum * 1_000_000));\n  } catch {\n    return undefined;\n  }\n}\n\n","import { ai } from '@ax-llm/ax';\nimport { privateKeyToAccount } from 'viem/accounts';\nimport { type Hex, wrapFetchWithPayment } from 'x402-fetch';\n\nconst DEFAULT_MODEL = 'gpt-5';\nconst DEFAULT_PROVIDER = 'openai';\nconst DEFAULT_API_URL = 'https://api-beta.daydreams.systems/v1';\nconst MAX_PAYMENT_BASE_UNITS = '10000000';\n\nexport type WrappedFetch = typeof fetch & {\n  preconnect?: () => Promise<void>;\n};\n\nexport type X402Account = Parameters<typeof wrapFetchWithPayment>[1];\n\nexport type CreateX402FetchOptions = {\n  account: X402Account;\n  fetchImpl?: typeof fetch;\n};\n\nexport const createX402Fetch = ({\n  account,\n  fetchImpl,\n}: CreateX402FetchOptions): WrappedFetch => {\n  if (!account) {\n    throw new Error('[agent-kit-payments] createX402Fetch requires an account');\n  }\n  const accountAddress =\n    typeof account === 'object' && account && 'address' in account\n      ? (account as { address?: string }).address\n      : undefined;\n  console.info(\n    '[agent-kit-payments:x402] creating paid fetch',\n    accountAddress ? `for ${accountAddress}` : '(account address unavailable)'\n  );\n  const paymentFetch = wrapFetchWithPayment(\n    (fetchImpl ?? fetch) as Parameters<typeof wrapFetchWithPayment>[0],\n    account,\n    BigInt(MAX_PAYMENT_BASE_UNITS)\n  ) as WrappedFetch;\n  console.info('[agent-kit-payments:x402] wrapFetchWithPayment initialised');\n  const describeInput = (input: Parameters<typeof fetch>[0]) => {\n    if (typeof input === 'string') return input;\n    if (input instanceof URL) return input.toString();\n    if (typeof (input as Request)?.url === 'string') {\n      return (input as Request).url;\n    }\n    return '[object Request]';\n  };\n  const wrappedFetch: WrappedFetch = Object.assign(\n    async (\n      input: Parameters<typeof fetch>[0],\n      init?: Parameters<typeof fetch>[1]\n    ) => {\n      const requestUrl = describeInput(input);\n      const requestMethod =\n        init?.method ??\n        (input instanceof Request ? input.method : undefined) ??\n        'POST';\n      console.info(\n        '[agent-kit-payments:x402] fetch request',\n        requestUrl,\n        requestMethod\n      );\n      try {\n        const response = await paymentFetch(input, init ?? {});\n        const paymentHeader = response.headers.get('X-PAYMENT-RESPONSE');\n        console.info(\n          '[agent-kit-payments:x402] fetch response',\n          requestUrl,\n          response.status,\n          paymentHeader ? '(paid)' : '(no x402 header)'\n        );\n        return response;\n      } catch (error) {\n        console.warn(\n          '[agent-kit-payments:x402] fetch failed',\n          requestUrl,\n          (error as Error)?.message ?? error\n        );\n        throw error;\n      }\n    },\n    {\n      preconnect: paymentFetch.preconnect ?? (async () => {}),\n    }\n  );\n  return wrappedFetch;\n};\n\nexport const accountFromPrivateKey = (privateKey: Hex): X402Account => {\n  if (!privateKey || privateKey.trim().length === 0) {\n    throw new Error(\n      '[agent-kit-payments] accountFromPrivateKey requires a non-empty private key'\n    );\n  }\n  return privateKeyToAccount(privateKey) as X402Account;\n};\n\n// ============================================================================\n// AxLLM Integration (x402 payment-enabled LLM client)\n// ============================================================================\n\ntype AiFactoryArgs = Parameters<typeof ai>[0];\ntype AiFactoryConfig = NonNullable<AiFactoryArgs['config']>;\ntype AiFactoryOptions = NonNullable<AiFactoryArgs['options']>;\n\nexport type CreateX402LLMOptions = {\n  account?: X402Account;\n  privateKey?: Hex;\n  fetch?: WrappedFetch;\n  fetchImpl?: typeof fetch;\n  model?: string;\n  ai?:\n    | (Record<string, unknown> & {\n        options?: Partial<AiFactoryOptions>;\n        config?: Partial<AiFactoryConfig>;\n      })\n    | undefined;\n};\n\nexport const createX402LLM = (\n  options: CreateX402LLMOptions = {}\n): ReturnType<typeof ai> => {\n  if (options.account) {\n    console.info(\n      '[agent-kit-payments:x402] initialising LLM with provided account'\n    );\n  } else if (options.privateKey) {\n    console.info(\n      '[agent-kit-payments:x402] deriving account from supplied private key'\n    );\n  } else {\n    console.info(\n      '[agent-kit-payments:x402] no explicit account/private key supplied; falling back to env or downstream defaults'\n    );\n  }\n\n  const account =\n    options.account ??\n    (options.privateKey\n      ? accountFromPrivateKey(options.privateKey)\n      : undefined);\n\n  if (!account) {\n    throw new Error(\n      '[agent-kit-payments] createX402LLM requires either an account or a private key'\n    );\n  }\n\n  const paymentFetch =\n    options.fetch ?? createX402Fetch({ account, fetchImpl: options.fetchImpl });\n  console.info('[agent-kit-payments:x402] payment-enabled fetch ready for LLM');\n\n  const aiOverrides = options.ai ?? {};\n  const {\n    config: configOverridesRaw,\n    options: optionOverridesRaw,\n    apiKey: apiKeyOverrideRaw,\n    apiURL: apiUrlOverrideRaw,\n    name: nameOverrideRaw,\n    ...restAiProps\n  } = aiOverrides;\n\n  const configOverrides =\n    configOverridesRaw && typeof configOverridesRaw === 'object'\n      ? (configOverridesRaw as Partial<AiFactoryConfig>)\n      : undefined;\n  const optionOverrides =\n    optionOverridesRaw && typeof optionOverridesRaw === 'object'\n      ? (optionOverridesRaw as Partial<AiFactoryOptions>)\n      : undefined;\n  const explicitApiKey =\n    typeof apiKeyOverrideRaw === 'string' && apiKeyOverrideRaw.trim().length > 0\n      ? apiKeyOverrideRaw\n      : undefined;\n  const nameOverride =\n    typeof nameOverrideRaw === 'string' && nameOverrideRaw.trim().length > 0\n      ? nameOverrideRaw\n      : undefined;\n  const apiUrlOverride =\n    typeof apiUrlOverrideRaw === 'string' && apiUrlOverrideRaw.trim().length > 0\n      ? apiUrlOverrideRaw\n      : undefined;\n\n  const apiKey = (explicitApiKey ?? process.env.OPENAI_API_KEY) as\n    | string\n    | undefined;\n\n  if (!apiKey) {\n    throw new Error(\n      '[agent-kit-payments] createX402LLM requires an OpenAI API key (set options.ai.apiKey or OPENAI_API_KEY)'\n    );\n  }\n\n  const baseConfig: AiFactoryConfig = {\n    stream: false,\n  };\n\n  const finalConfig = {\n    ...baseConfig,\n    ...(configOverrides ?? {}),\n  } as AiFactoryConfig;\n\n  const finalOptions = {\n    ...(optionOverrides ?? {}),\n    fetch: paymentFetch,\n  } as AiFactoryOptions;\n\n  const aiArgs = {\n    ...restAiProps,\n    name: nameOverride ?? DEFAULT_PROVIDER,\n    apiKey,\n    apiURL: apiUrlOverride ?? DEFAULT_API_URL,\n    config: finalConfig,\n    options: finalOptions,\n  } as AiFactoryArgs;\n\n  console.info(\n    '[agent-kit-payments:x402] creating Ax client',\n    `provider=${aiArgs.name}`,\n    `model=${finalConfig.model}`\n  );\n\n  return ai(aiArgs);\n};\n\nexport const x402LLM = ({\n  privateKey = process.env.PRIVATE_KEY as Hex,\n  model = DEFAULT_MODEL,\n  apiURL = DEFAULT_API_URL,\n}: {\n  privateKey: Hex;\n  model?: string;\n  apiURL?: string;\n}) =>\n  createX402LLM({\n    privateKey,\n    model,\n    ai: { apiURL },\n  });\n","import { z } from 'zod';\n\nconst OutgoingLimitSchema = z.object({\n  maxPaymentUsd: z.number().positive().optional(),\n  maxTotalUsd: z.number().positive().optional(),\n  windowMs: z.number().int().positive().optional(),\n});\n\nconst OutgoingLimitsConfigSchema = z.object({\n  global: OutgoingLimitSchema.optional(),\n  perTarget: z.record(z.string(), OutgoingLimitSchema).optional(),\n  perEndpoint: z.record(z.string(), OutgoingLimitSchema).optional(),\n});\n\nconst IncomingLimitSchema = z.object({\n  maxPaymentUsd: z.number().positive().optional(),\n  maxTotalUsd: z.number().positive().optional(),\n  windowMs: z.number().int().positive().optional(),\n});\n\nconst IncomingLimitsConfigSchema = z.object({\n  global: IncomingLimitSchema.optional(),\n  perSender: z.record(z.string(), IncomingLimitSchema).optional(),\n  perEndpoint: z.record(z.string(), IncomingLimitSchema).optional(),\n});\n\nconst RateLimitConfigSchema = z.object({\n  maxPayments: z.number().int().positive(),\n  windowMs: z.number().int().positive(),\n});\n\nexport const PaymentPolicyGroupSchema = z.object({\n  name: z.string().min(1),\n  outgoingLimits: OutgoingLimitsConfigSchema.optional(),\n  incomingLimits: IncomingLimitsConfigSchema.optional(),\n  allowedRecipients: z.array(z.string()).optional(),\n  blockedRecipients: z.array(z.string()).optional(),\n  allowedSenders: z.array(z.string()).optional(),\n  blockedSenders: z.array(z.string()).optional(),\n  rateLimits: RateLimitConfigSchema.optional(),\n});\n\n/**\n * Zod schema for PaymentPolicyGroup array.\n */\nexport const PaymentPolicyGroupsSchema = z.array(PaymentPolicyGroupSchema);\n\n","import { readFileSync } from 'node:fs';\nimport { join } from 'node:path';\nimport type { PaymentPolicyGroup } from '@lucid-agents/types/payments';\n\nimport { PaymentPolicyGroupsSchema } from './policy-schema';\n\n/**\n * Loads payment policy groups from a config file.\n * Looks for payment-policies.json in the current working directory.\n *\n * @param configPath - Optional path to config file (defaults to 'payment-policies.json' in cwd)\n * @returns Array of validated policy groups, or undefined if file doesn't exist\n * @throws Error if file exists but is invalid\n */\nexport function loadPoliciesFromConfig(\n  configPath?: string\n): PaymentPolicyGroup[] | undefined {\n  const filePath = configPath ?? join(process.cwd(), 'payment-policies.json');\n\n  try {\n    const fileContent = readFileSync(filePath, 'utf-8');\n    const json = JSON.parse(fileContent);\n\n    const result = PaymentPolicyGroupsSchema.safeParse(json);\n    if (!result.success) {\n      throw new Error(\n        `Invalid payment policies config: ${result.error.issues\n          .map(e => `${e.path.join('.')}: ${e.message}`)\n          .join(', ')}`\n      );\n    }\n\n    return result.data;\n  } catch (error) {\n    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n      return undefined;\n    }\n\n    if (error instanceof SyntaxError) {\n      throw new Error(\n        `Failed to parse payment-policies.json: ${error.message}`\n      );\n    }\n\n    if (error instanceof Error) {\n      throw error;\n    }\n\n    throw new Error('Failed to load payment policies config');\n  }\n}\n\n","import type { PaymentPolicyGroup } from '@lucid-agents/types/payments';\n\nimport { loadPoliciesFromConfig } from './policy-config';\n\n/**\n * Loads payment policy groups from a config file.\n *\n * Example `payment-policies.json`:\n * ```json\n * [\n *   {\n *     \"name\": \"Daily Outgoing Limit\",\n *     \"outgoingLimits\": {\n *       \"global\": {\n *         \"maxPaymentUsd\": 10.0,\n *         \"maxTotalUsd\": 1000.0,\n *         \"windowMs\": 86400000\n *       },\n *       \"perTarget\": {\n *         \"https://agent.example.com\": {\n *           \"maxTotalUsd\": 500.0\n *         }\n *       },\n *       \"perEndpoint\": {\n *         \"https://agent.example.com/entrypoints/process/invoke\": {\n *           \"maxTotalUsd\": 100.0\n *         }\n *       }\n *     },\n *     \"incomingLimits\": {\n *       \"global\": {\n *         \"maxTotalUsd\": 5000.0\n *       }\n *     },\n *     \"allowedRecipients\": [\"https://trusted.example.com\"],\n *     \"blockedSenders\": [\"0x123...\"],\n *     \"rateLimits\": {\n *       \"maxPayments\": 100,\n *       \"windowMs\": 3600000\n *     }\n *   }\n * ]\n * ```\n *\n * @param configPath - Optional path to config file (defaults to 'payment-policies.json' in cwd)\n * @returns Array of policy groups or undefined if file doesn't exist\n */\nexport function policiesFromConfig(\n  configPath?: string\n): PaymentPolicyGroup[] | undefined {\n  return loadPoliciesFromConfig(configPath);\n}\n","import type {\n  AgentRuntime,\n  BuildContext,\n  EntrypointDef,\n  Extension,\n} from '@lucid-agents/types/core';\nimport type { AgentCardWithEntrypoints } from '@lucid-agents/types/a2a';\nimport type {\n  PaymentsConfig,\n  PaymentsRuntime,\n} from '@lucid-agents/types/payments';\n\nimport { createAgentCardWithPayments } from './manifest';\nimport { createPaymentsRuntime, entrypointHasExplicitPrice } from './payments';\nimport { policiesFromConfig } from './env';\nimport type { PaymentStorageConfig } from '@lucid-agents/types/payments';\nimport type { PaymentStorage } from './payment-storage';\n\ntype PaymentStorageFactory = (\n  storageConfig?: PaymentStorageConfig,\n  agentId?: string\n) => PaymentStorage;\n\nexport function payments(options?: {\n  config?: PaymentsConfig | false;\n  policies?: string;\n  agentId?: string;\n  storageFactory?: PaymentStorageFactory;\n}): Extension<{ payments?: PaymentsRuntime }> {\n  let paymentsRuntime: PaymentsRuntime | undefined;\n\n  return {\n    name: 'payments',\n    build(ctx: BuildContext): { payments?: PaymentsRuntime } {\n      let config = options?.config;\n\n      if (config !== false && config !== undefined && options?.policies) {\n        try {\n          const policyGroups = policiesFromConfig(options.policies);\n          if (policyGroups) {\n            config = { ...config, policyGroups };\n          }\n        } catch (error) {\n          const message =\n            error instanceof Error ? error.message : String(error);\n          throw new Error(`Failed to load policies from config: ${message}`, {\n            cause: error,\n          });\n        }\n      }\n\n      paymentsRuntime = createPaymentsRuntime(\n        config,\n        options?.agentId,\n        options?.storageFactory\n      );\n      return { payments: paymentsRuntime };\n    },\n    onEntrypointAdded(entrypoint: EntrypointDef, runtime: AgentRuntime) {\n      if (\n        paymentsRuntime &&\n        !paymentsRuntime.isActive &&\n        paymentsRuntime.config\n      ) {\n        if (entrypointHasExplicitPrice(entrypoint)) {\n          paymentsRuntime.activate(entrypoint);\n        }\n      }\n    },\n    onManifestBuild(\n      card: AgentCardWithEntrypoints,\n      runtime: AgentRuntime\n    ): AgentCardWithEntrypoints {\n      if (paymentsRuntime?.config) {\n        return createAgentCardWithPayments(\n          card,\n          paymentsRuntime.config,\n          runtime.entrypoints.snapshot()\n        );\n      }\n      return card;\n    },\n  };\n}\n"]}